var documenterSearchIndex = {"docs":
[{"location":"generated/isomorphisms/#Isomorphisms","page":"Isomorphisms","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the QuantumSystem type to perform quantum dynamics.","category":"page"},{"location":"generated/isomorphisms/#Quantum-state-isomorphisms","page":"Isomorphisms","title":"Quantum state isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"ket_to_iso is the real isomorphism of a quantum state œà ‚àà ‚ÑÇ‚Åø\niso_to_ket is the inverse isomorphism of a real vector œàÃÉ ‚àà ‚Ñù¬≤‚Åø","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"œà = [1; 2] + im * [3; 4]\nœàÃÉ = ket_to_iso(œà)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_to_ket(œàÃÉ)","category":"page"},{"location":"generated/isomorphisms/#Quantum-operator-isomorphisms","page":"Isomorphisms","title":"Quantum operator isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"We often need to convert a complex matrix U to a real vector UÃÉ‚Éó. We provoide the following isomorphisms to convert between the two representations.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù})\noperator_to_iso_vec(U::AbstractVector{‚ÑÇ})\niso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù})\niso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù})\niso_operator_to_operator(UÃÉ::AbstractMatrix{‚Ñù})\noperator_to_iso_operator(U::AbstractMatrix{‚ÑÇ})","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"In additon, we provide mat(x::AbstractVector) to convert a vector x into a square matrix, as the inverse to Base's vec.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Julia uses column-major order.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"U = [1 5; 2 6] + im * [3 7; 4 8]\nUÃÉ‚Éó = operator_to_iso_vec(U)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_vec_to_operator(UÃÉ‚Éó)","category":"page"},{"location":"generated/isomorphisms/#Density-matrix-isomorphisms","page":"Isomorphisms","title":"Density matrix isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The isomorphisms for density matrices are:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"density_to_iso_vec(œÅ::AbstractMatrix{‚ÑÇ})\niso_vec_to_density(œÅÃÉ::AbstractVector{‚Ñù})","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"warning: Warning\nThe isomorphism density_to_iso_vec is not the same as operator_to_iso_vec.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"œÅ = [1 2; 3 4] + im * [5 6; 7 8]\nœÅÃÉ‚Éó = density_to_iso_vec(œÅ)","category":"page"},{"location":"generated/isomorphisms/#Quantum-dynamics-isomorphisms","page":"Isomorphisms","title":"Quantum dynamics isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the QuantumSystem type.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The Isomorphisms.iso isomorphism of a Hamiltonian H is:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"textiso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"where Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Hence, the generator Isomorphisms.G associated to a Hamiltonian H is:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"G(H) = textiso(- i widetildeH) = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Quantum-Systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem <: AbstractQuantumSystem\n\nA composite quantum system consisting of multiple subsystems with optional coupling terms.\n\nComposite systems represent multiple quantum subsystems (e.g., multiple qubits or oscillators) that may be coupled together. Each subsystem's Hamiltonians are automatically lifted to the  full tensor product space, and subsystem drives are appended to any coupling drives.\n\nFields\n\nH::Function: The total Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The total drift Hamiltonian including subsystem drifts and couplings\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: All drive Hamiltonians (coupling drives + subsystem drives)\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control\nn_drives::Int: Total number of control drives\nlevels::Int: Total dimension of the composite system (product of subsystem dimensions)\nsubsystem_levels::Vector{Int}: Dimensions of each subsystem\nsubsystems::Vector{QuantumSystem}: The individual quantum subsystems\n\nSee also QuantumSystem, lift_operator.\n\nExample\n\n# Two qubits with ZZ coupling\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [(-1.0, 1.0)])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], 10.0, Float64[])\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:QuantumSystem}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    T_max::Float64,\n    drive_bounds::Vector\n)\n\nConstruct a CompositeQuantumSystem with coupling drift and drive terms.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian (in full tensor product space)\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector: Drive bounds for the coupling drives (subsystem bounds are inherited)\n\nThe total drift includes both the coupling drift and all subsystem drifts (automatically lifted). The total drives include coupling drives followed by all subsystem drives (automatically lifted).\n\nExample\n\nsys1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], 10.0, [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [(-1.0, 1.0)])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drift\ncsys = CompositeQuantumSystem(g12, Matrix{ComplexF64}[], [sys1, sys2], 10.0, Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{<:QuantumSystem}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    subsystems::AbstractVector{<:QuantumSystem},\n    T_max::Float64,\n    drive_bounds::Vector\n)\n\nConvenience constructor for a composite system with no coupling terms (neither drift nor drives).\n\nUse this when you have independent subsystems that you want to represent in a single composite space, but without any direct coupling between them.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [1.0])\ncsys = CompositeQuantumSystem([sys1, sys2], 10.0, Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{<:QuantumSystem}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    subsystems::AbstractVector{<:QuantumSystem},\n    T_max::Float64,\n    drive_bounds::Vector\n)\n\nConvenience constructor for a composite system with coupling drift but no coupling drives.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [1.0])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])  # coupling drift\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], 10.0, Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:QuantumSystem}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    T_max::Float64,\n    drive_bounds::Vector\n)\n\nConvenience constructor for a composite system with coupling drives but no coupling drift.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drive\ncsys = CompositeQuantumSystem([g12], [sys1, sys2], 10.0, [(-1.0, 1.0)])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\nparams::Dict{Symbol, Any}: Additional parameters\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}},\n    T_max::Float64,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    params::Dict{Symbol, <:Any}=Dict{Symbol, Any}()\n)\nOpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number}, \n    T_max::Float64, \n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    params::Dict{Symbol, <:Any}=Dict{Symbol, Any}()\n)\nOpenQuantumSystem(\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    T_max::Float64, \n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    params::Dict{Symbol, <:Any}=Dict{Symbol, Any}()\n)\nOpenQuantumSystem(\n    H::Function, \n    T_max::Float64,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    params::Dict{Symbol, <:Any}=Dict{Symbol, Any}()\n)\nOpenQuantumSystem(\n    system::QuantumSystem; \n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    params::Dict{Symbol, <:Any}=Dict{Symbol, Any}()\n)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators. All constructors require Tmax (maximum time) and drivebounds (control bounds for each drive) to be explicitly specified.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians (control-dependent components)\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    T_max::Float64,\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}}\n)\n\nConstruct a QuantumSystem from drift and drive Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians, one for each control\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector: Drive amplitude bounds for each control. Can be tuples (lower, upper) or scalars\n\nThe resulting Hamiltonian is: H(u, t) = Hdrift + Œ£·µ¢ u·µ¢ * Hdrives[i]\n\nExample\n\nsys = QuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    10.0,                          # T_max\n    [(-1.0, 1.0), (-1.0, 1.0)]     # bounds\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Tuple{Function, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H::Function, T_max::Float64, drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}})\n\nConstruct a QuantumSystem from a Hamiltonian function.\n\nArguments\n\nH::Function: Hamiltonian function with signature (u, t) -> H(u, t) where u is the control vector and t is time\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector: Drive amplitude bounds. Can be tuples (lower, upper) or scalars (interpreted as (-bound, bound))\n\nExample\n\n# Define a time-dependent Hamiltonian\nH = (u, t) -> PAULIS[:Z] + u[1] * PAULIS[:X] + u[2] * PAULIS[:Y]\nsys = QuantumSystem(H, 10.0, [(-1.0, 1.0), (-1.0, 1.0)])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{AbstractMatrix{‚ÑÇ}, Float64}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::AbstractMatrix, T_max::Float64)\n\nConvenience constructor for a system with only a drift Hamiltonian (no drives).\n\nExample\n\nsys = QuantumSystem(PAULIS[:Z], 10.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Float64, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drives::Vector{<:AbstractMatrix}, T_max::Float64, drive_bounds::Vector)\n\nConvenience constructor for a system with no drift Hamiltonian (H_drift = 0).\n\nExample\n\nsys = QuantumSystem([PAULIS[:X], PAULIS[:Y]], 10.0, [1.0, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.\n\nVariational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nG_vars::AbstractVector{<:Function}: Variational generator functions, one for each perturbation direction\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\nparams::Dict{Symbol, Any}: Additional parameters for the system\n\nSee also QuantumSystem, OpenQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    H_vars::AbstractVector{<:AbstractMatrix};\n    params::Dict{Symbol,Any}=Dict{Symbol,Any}()\n)\n\nConstruct a VariationalQuantumSystem from drift, drive, and variational Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::AbstractVector{<:AbstractMatrix}: Vector of drive Hamiltonians for control\nH_vars::AbstractVector{<:AbstractMatrix}: Vector of variational Hamiltonians representing perturbation directions\nparams::Dict{Symbol,Any}: Optional additional parameters\n\nThe variational operators allow sensitivity analysis by exploring how dynamics change under perturbations: Hperturbed = H + Œ£·µ¢ Œµ·µ¢ * Hvars[i]\n\nExample\n\nvarsys = VariationalQuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [PAULIS[:X]]                   # variational perturbations\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","text":"get_drift(sys::AbstractQuantumSystem)\n\nReturns the drift Hamiltonian of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","text":"get_drives(sys::AbstractQuantumSystem)\n\nReturns the drive Hamiltonians of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.lift_operator","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.lift_operator","text":"lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Gates","page":"Library","title":"Gates","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.Gates.GATES","page":"Library","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#PiccoloQuantumObjects.Gates.PAULIS","page":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","text":"The 2√ó2 Pauli matrics and identity.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Embedded-Operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","text":"AbstractPiccoloOperator\n\nUnion type for operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...)\n\nEmbed the subspace_operator into a quantum system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","text":"get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of the quantum system with an excitation restriction.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","text":"get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the leakage in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","text":"get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the states that are outside of the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Isomorphisims","page":"Library","title":"Isomorphisims","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH, i.e. G(H) = textiso(-iH).\n\nSee also Isomorphisms.iso, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Real})\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H.\n\nSee also Isomorphisms.iso, Isomorphisms.G.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","text":"ad_vec(H::AbstractMatrix{‚ÑÇ}; anti::Bool=false) where ‚ÑÇ <: Number\n\nReturns the vectorized adjoint action of a matrix H:\n\ntextad_vec(H) = mqty(1  0  0  1) otimes H - (-1)^textanti mqty(0  1  1  0) otimes H^*\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","text":"density_to_iso_vec(œÅ::AbstractMatrix{<:Number})\n\nReturns the isomorphism œÅ‚ÉóÃÉ = ket_to_iso(vec(œÅ)) of a density matrix œÅ\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","text":"iso(H::AbstractMatrix{<:Number})\n\nReturns the isomorphism of H:\n\niso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde  indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nSee also Isomorphisms.G, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","text":"iso_D(L::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nReturns the isomorphic representation of the Lindblad dissipator L.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real matrix UÃÉ representing an isomorphism operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","text":"iso_operator_to_operator(UÃÉ)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","text":"iso_to_ket(œàÃÉ::AbstractVector{<:Real})\n\nConvert a real isomorphism vector œàÃÉ into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","text":"iso_vec_to_density(œÅ‚ÉóÃÉ::AbstractVector{<:Real})\n\nReturns the density matrix œÅ from its isomorphism œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a real matrix representing an isomorphism operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a complex matrix representing an operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","text":"ket_to_iso(œà::AbstractVector{<:Number})\n\nConvert a ket vector œà into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","text":"operator_to_iso_operator(U)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nConvert a complex matrix U representing an operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{<:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1<:Real, ‚Ñù2<:Real}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.var_G","text":"var_G(G::AbstractMatrix{<:Real}, G_vars::AbstractVector{<:AbstractMatrix{<:Real}})\n\nReturns the variational generator of G with variational derivatives, G_vars.\n\nThe variational generator is \n\ntextvar_G(G G_a G_b) = mqty( G  0  0  G_a  G  0  G_b  0  G )\n\nwhere G is the isomorphism of a Hamiltonian and G_a and G_b are the variational  derivatives of G for parameters a and b, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Object-Utilities","page":"Library","title":"Quantum Object Utilities","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for an n-dimensional system with a given radius. The smaller the radius, the closer the matrix will be to the identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","text":"operator_from_string(operator::String; lookup=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-System-Utilities","page":"Library","title":"Quantum System Utilities","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent","text":"is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true)\n\nCheck if the columns of the matrix M are linearly dependent.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","text":"operator_algebra(generators; kwargs...)\n\nCompute the Lie algebra basis for the given generators.\n\nArguments\n\ngenerators::Vector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nreturn_layers::Bool=false: return the Lie tree layers\nnormalize::Bool=false: normalize the basis\nverbose::Bool=false: print information\nremove_trace::Bool=true: remove trace from generators\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's Tmax and drivebounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","text":"fidelity(œÅ::AbstractMatrix{<:Number}, œÅ_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between two density matrices œÅ and œÅ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","text":"fidelity(œà::AbstractVector{<:Number}, œà_goal::AbstractVector{<:Number})\n\nCalculate the fidelity between two quantum states œà and œà_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.free_phase-Union{Tuple{‚ÑÇ}, Tuple{AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix{<:‚ÑÇ}}}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Rollouts.free_phase","text":"free_phase(phases::AbstractVector{<:Real}, phase_operators::AbstractVector{<:AbstractMatrix{<:‚ÑÇ}})\n\nRotate the phase_operators by the phases and return the Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.infer_is_evp","text":"infer_is_evp(integrator::Function)\n\nInfer whether the integrator is a exponential-vector product (EVP) function.\n\nIf true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.open_rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","text":"open_rollout(\n    œÅ‚Éó‚ÇÅ::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n)\n\nRollout a quantum state œÅ‚Éó‚ÇÅ under the control controls for a time Œît\n\nArguments\n\nœÅ‚Éó‚ÇÅ::AbstractVector{<:Complex}: Initial state vector\ncontrols::AbstractMatrix{<:Real}: Control matrix\nŒît::AbstractVector: Time steps\nsystem::OpenQuantumSystem: Quantum system\n\nKeyword Arguments\n\nshow_progress::Bool=false: Show progress bar\nintegrator::Function=expv: Integrator function\nexp_vector_product::Bool: Infer whether the integrator is an exponential-vector product\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{<:Complex}, AbstractMatrix{<:Real}, AbstractVector, OpenQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout","text":"open_rollout(\n    œÅ‚ÇÅ::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n)\n\nRollout a density matrix œÅ‚ÇÅ under the control controls and timesteps Œît\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","page":"Library","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","text":"open_rollout_fidelity(\n    œÅ‚Éó‚ÇÅ::AbstractVector{<:Complex},\n    œÅ‚Éó‚ÇÇ::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    œÅ‚ÇÅ::AbstractMatrix{<:Complex},\n    œÅ‚ÇÇ::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:œÅ‚ÉóÃÉ,\n    control_name::Symbol=:a,\n    kwargs...\n)\n\nCalculate the fidelity between the final state of an open quantum system rollout and a goal state.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout","text":"rollout(\n    œàÃÉ_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    œà_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\n\nRollout a quantum state œàÃÉ_init under the control controls for a time Œît using the system system.\n\nIf exp_vector_product is true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\nTypes should allow for autodifferentiable controls and times.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.rollout_fidelity","page":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","text":"rollout_fidelity(\n    œàÃÉ_init::AbstractVector{<:Real},\n    œàÃÉ_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    œà_init::AbstractVector{<:Complex},\n    œà_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n)\n\nCalculate the fidelity between the final state of a rollout and a goal state.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_fidelity","text":"unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between unitary operators U and U_goal in the subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector{<:Real}, AbstractVector{<:AbstractMatrix}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_free_phase_fidelity","text":"unitary_free_phase_fidelity(\n    U::AbstractMatrix,\n    U_goal::AbstractMatrix,\n    phases::AbstractVector{<:Real},\n    phase_operators::AbstractVector{<:AbstractMatrix};\n    subspace::AbstractVector{Int}=axes(U, 1)\n)\n\nCalculate the fidelity between unitary operators U and U_goal in the subspace, including the phase rotations about the phase_operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","text":"unitary_rollout(\n    UÃÉ‚Éó_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\n\nRollout a isomorphic unitary operator UÃÉ‚Éó_init under the control controls for a time Œît using the system system.\n\nArguments\n\nUÃÉ‚Éó_init::AbstractVector{<:Real}: Initial unitary vector\ncontrols::AbstractMatrix{<:Real}: Control matrix\nŒît::AbstractVector: Time steps\nsystem::AbstractQuantumSystem: Quantum system\n\nKeyword Arguments\n\nshow_progress::Bool=false: Show progress bar\nintegrator::Function=expv: Integrator function\nexp_vector_product::Bool: Infer whether the integrator is an exponential-vector product\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","page":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","text":"unitary_rollout_fidelity(\n    UÃÉ‚Éó_init::AbstractVector{<:Real},\n    UÃÉ‚Éó_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    UÃÉ‚Éó_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n)\n\nCalculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If phases and phase_operators are provided, the free phase unitary fidelity is calculated.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.variational_rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.variational_rollout","text":"variational_rollout(\n    œàÃÉ_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector{<:Real},\n    system::VariationalQuantumSystem;\n    show_progress::Bool=false,\n    integrator::Function=expv,\n    exp_vector_product::Bool=infer_is_evp(integrator)\n)\nvariational_rollout(œà::Vector{<:Complex}, args...; kwargs...)\nvariational_rollout(inits::AbstractVector{<:AbstractVector}, args...; kwargs...)\nvariational_rollout(\n    traj::NamedTrajectory, \n    system::AbstractQuantumSystem; \n    state_name::Symbol=:œàÃÉ,\n    drive_name::Symbol=:a,\n    kwargs...\n)\n\nSimulates the variational evolution of a quantum state under a given control trajectory.\n\nReturns\n\nŒ®ÃÉ::Matrix{<:Real}: The evolved quantum state at each timestep.\nŒ®ÃÉ_vars::Vector{<:Matrix{<:Real}}: The variational derivatives of the    quantum state with respect to the variational parameters.\n\nNotes\n\nThis function computes the variational evolution of a quantum state using the  variational generators of the system. It supports autodifferentiable controls and  timesteps, making it suitable for optimization tasks. The variational derivatives are  computed alongside the state evolution, enabling sensitivity analysis and gradient-based  optimization.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.variational_unitary_rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.variational_unitary_rollout","text":"variational_unitary_rollout(\n    UÃÉ‚Éó_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector{<:Real},\n    system::VariationalQuantumSystem;\n    show_progress::Bool=false,\n    integrator::Function=expv,\n    exp_vector_product::Bool=infer_is_evp(integrator)\n)\nvariational_unitary_rollout(\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::VariationalQuantumSystem;\n    kwargs...\n)\nvariational_unitary_rollout(\n    traj::NamedTrajectory,\n    system::VariationalQuantumSystem;\n    unitary_name::Symbol=:UÃÉ‚Éó,\n    drive_name::Symbol=:a,\n    kwargs...\n)\n\nSimulates the variational evolution of a quantum state under a given control trajectory.\n\nReturns\n\nUÃÉ‚Éó::Matrix{<:Real}: The evolved unitary at each timestep.\nUÃÉ‚Éó_vars::Vector{<:Matrix{<:Real}}: The variational derivatives of the  unitary with    respect to the variational parameters.\n\nNotes\n\nThis function computes the variational evolution of a unitary using the  variational generators of the system. It supports autodifferentiable controls and  timesteps, making it suitable for optimization tasks. The variational derivatives are  computed alongside the state evolution, enabling sensitivity analysis and gradient-based  optimization.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/#Quantum-Objects","page":"Quantum Objects","title":"Quantum Objects","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n‚äó = kron;\nnothing #hide","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices.","category":"page"},{"location":"generated/quantum_objects/#Quantum-states","page":"Quantum Objects","title":"Quantum states","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state g, excited state e, etc.).","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Ground state in a 2-level system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_string(\"g\", [2])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Superposition state coupled to a ground state in two 2-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_string(\"(g+e)g\", [2,2])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"|01‚ü© in a 2-qubit system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_bitstring(\"01\")","category":"page"},{"location":"generated/quantum_objects/#Quantum-operators","page":"Quantum Objects","title":"Quantum operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Frequently used operators are provided in PAULIS and GATES.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Quantum operators can also be constructed from strings.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"operator_from_string(\"X\")","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"operator_from_string(\"XZ\")","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Annihilation and creation operators are provided for oscillator systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a = annihilate(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a‚Å∫ = create(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a'a","category":"page"},{"location":"generated/quantum_objects/#Random-operators","page":"Quantum Objects","title":"Random operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The haar_random function draws random unitary operators according to the Haar measure.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_random(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"If we want to generate random operations that are close to the identity, we can use the haar_identity function.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_identity(2, 0.1)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"A smaller radius means the random operator is closer to the identity.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_identity(2, 0.01)","category":"page"},{"location":"generated/quantum_objects/#Embedded-operators","page":"Quantum Objects","title":"Embedded operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Sometimes we want to embed a quantum operator into a larger Hilbert space, mathcalH, which we decompose into subspace and leakage components:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"    mathcalH = mathcalH_textsubspace oplus mathcalH_textleakage","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"In quantum computing, the computation is encoded in a subspace, while the remaining leakage states should be avoided.","category":"page"},{"location":"generated/quantum_objects/#The-embed-and-unembed-functions","page":"Quantum Objects","title":"The embed and unembed functions","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The embed function allows to embed a quantum operator in a larger Hilbert space.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\nembed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The unembed function allows to unembed a quantum operator from a larger Hilbert space.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\nunembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\nunembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed a two-level X gate into a multilevel system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Unembed to retrieve the original operator.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"X_original = unembed(X_embedded, subspace_indices)","category":"page"},{"location":"generated/quantum_objects/#The-EmbeddedOperator-type","page":"Quantum Objects","title":"The EmbeddedOperator type","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The EmbeddedOperator type stores information about an operator embedded in the subspace of a larger quantum system.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"We construct an embedded operator in the same manner as the embed function.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed an X gate in the first qubit's subspace within two 3-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"gate = GATES[:X] ‚äó GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Show the full operator.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"embedded_operator.operator .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Get the original operator back.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"unembed(embedded_operator) .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embedded operators for composite systems are also supported.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"This is a two step process.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The provided subspace operator is lift_operator-ed  from the subsystem_indices where  it is defined into the space spanned by the composite system's subspaces.\nThe lifted operator is embedded into the full Hilbert space spanned by the  subsystem_levels.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/#Subspace-and-leakage-indices","page":"Quantum Objects","title":"Subspace and leakage indices","text":"","category":"section"},{"location":"generated/quantum_objects/#The-get_subspace_indices-function","page":"Quantum Objects","title":"The get_subspace_indices function","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The get_subspace_indices function is a convenient way to get the indices of a subspace in a larger quantum system.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Its dual function is get_leakage_indices.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices([1:2, 1:2], [3, 3])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Qubits are assumed if the indices are not provided.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices([3, 3])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_leakage_indices([3, 3])","category":"page"},{"location":"generated/quantum_objects/#Excitation-number-restrictions","page":"Quantum Objects","title":"Excitation number restrictions","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_enr_subspace_indices(1, [3, 3])","category":"page"},{"location":"generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","page":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"For isomorphic operators, the get_iso_vec_subspace_indices function can be used to find the appropriate vector indices of the equivalent operator subspace. See also, Isomorphisms#Quantum-operator-isomorphisms.","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Its dual function is get_iso_vec_leakage_indices, which by default only returns the leakage indices of the blocks:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"mathcalH_textsubspace otimes mathcalH_textsubspacequad\nmathcalH_textsubspace otimes mathcalH_textleakagequad\nmathcalH_textleakage otimes mathcalH_textsubspace","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_iso_vec_subspace_indices(1:2, 3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Show the pure-leakage indices.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The pure-leakage indices can grow quickly!","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quantum_systems/#Abstract-Quantum-Systems","page":"Quantum Systems","title":"Abstract Quantum Systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n‚äó = kron;\nnothing #hide","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The QuantumSystem type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians,","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H(u t) = H_textdrift + sum_i u_i H_textdrives^(i)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"where u is the control vector and t is time.","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians (control-dependent components)\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"QuantumSystem's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. All systems require explicit specification of T_max (maximum time) and drive_bounds (control bounds).","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nT_max = 10.0\ndrive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nsystem = QuantumSystem(H_drift, H_drives, T_max, drive_bounds)\n\nu_controls = [1.0, 0.0]\nt = 0.0\nsystem.H(u_controls, t)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"To extract the drift and drive Hamiltonians from a QuantumSystem, use the get_drift and get_drives functions.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Get the X drive.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives = get_drives(system)\ndrives[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"And the Y drive.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"note: Note\nWe can also construct a QuantumSystem directly from a Hamiltonian function. The function must accept (u, t) arguments where u is the control vector and t is time.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H(u, t) = PAULIS[:Z] + u[1] * PAULIS[:X] + u[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 10.0, [(-1.0, 1.0), (-1.0, 1.0)])\nsystem.H([1.0, 0.0], 0.0) |> sparse","category":"page"},{"location":"generated/quantum_systems/#Open-quantum-systems","page":"Quantum Systems","title":"Open quantum systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"We can also construct an OpenQuantumSystem with Lindblad dynamics, enabling a user to pass a list of dissipation operators.","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians\nT_max::Float64: Maximum evolution time\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\nparams::Dict{Symbol, Any}: Additional parameters\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Add a dephasing and annihilation error channel.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nT_max = 10.0\ndrive_bounds = [(-1.0, 1.0)]\nsystem = OpenQuantumSystem(H_drives, T_max, drive_bounds, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system.dissipation_operators[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"warning: Warning\nThe Hamiltonian part system.H excludes the Lindblad operators. This is also true for functions that report properties of system.H, such as get_drift, get_drives, and is_reachable.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/#Composite-quantum-systems","page":"Quantum Systems","title":"Composite quantum systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"A CompositeQuantumSystem is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system_1 = QuantumSystem([PAULIS[:X]], 1.0, [(-1.0, 1.0)])\nsystem_2 = QuantumSystem([PAULIS[:Y]], 1.0, [(-1.0, 1.0)])\nH_drift = PAULIS[:Z] ‚äó PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, Matrix{ComplexF64}[], [system_1, system_2], 1.0, Float64[]);\nnothing #hide","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The drift Hamiltonian is the ZZ coupling.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The drives are the X and Y operators on the first and second subsystems.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives = get_drives(system)\ndrives[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/#The-lift_operator-function","page":"Quantum Systems","title":"The lift_operator function","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"To lift operators acting on a subsystem into the full Hilbert space, use lift_operator.","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.lift_operator-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.lift_operator","text":"lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create an a + a' operator acting on the 1st subsystem of a qutrit and qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"subspace_levels = [3, 2]\nlift_operator(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create IXI operator on the 2nd qubit in a 3-qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift_operator(PAULIS[:X], 2, 3) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create an XX operator acting on qubits 3 and 4 in a 4-qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift_operator([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"#_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift_operator(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift_operator(GATES[:CX], [1, 3], 3) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/#Reachability-tests","page":"Quantum Systems","title":"Reachability tests","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the is_reachable function.","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\nis_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Y can be reached by commuting Z and X.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], 1.0, [(-1.0, 1.0)])\nis_reachable(PAULIS[:Y], system)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Y cannot be reached by X alone.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system = QuantumSystem([PAULIS[:X]], 1.0, [(-1.0, 1.0)])\nis_reachable(PAULIS[:Y], system)","category":"page"},{"location":"generated/quantum_systems/#Direct-sums","page":"Quantum Systems","title":"Direct sums","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The direct sum of two quantum systems is constructed with the direct_sum function.","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\ndirect_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\ndirect_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\ndirect_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's Tmax and drivebounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], 10.0, [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create a pair of non-interacting qubits.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system_1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], 1.0, [(-1.0, 1.0), (-1.0, 1.0)])\nsystem_2 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], 1.0, [(-1.0, 1.0), (-1.0, 1.0)])\nsystem = direct_sum(system_1, system_2)\nget_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/PiccoloQuantumObjects/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/PiccoloQuantumObjects/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/PiccoloQuantumObjects.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/PiccoloQuantumObjects.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/PiccoloQuantumObjects.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/PiccoloQuantumObjects.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n<i> Make simple transformation of complex objects for quantum numerics </i>\n<br>\n\n</div>","category":"page"},{"location":"#PiccoloQuantumObjects","page":"Home","title":"PiccoloQuantumObjects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PiccoloQuantumObjects.jl is a Julia package for working with quantum objects. It provides tools for constructing and manipulating quantum states and operators. It is designed to be used with other packages in the Piccolo.jl ecosystem, such as QuantumCollocation.jl and NamedTrajectories.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is registered! To install, enter the Julia REPL, type ] to enter pkg mode, and then run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PiccoloQuantumObjects","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example demonstrates how to create a quantum state, create a quantum operator, and apply the operator to the state:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PiccoloQuantumObjects\n\n# Create a quantum state\nstate = ket_from_string(\"g\", [2])\n\n# Create a quantum operator\noperator = PAULIS.X\n\n# Apply the operator to the state\nnew_state = operator * state\n\n# Transform the state to its real representation\nnew_iso_state = ket_to_iso(new_state)\n\n# Transform back\niso_to_ket(new_iso_state)","category":"page"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/","category":"page"},{"location":"","page":"Home","title":"Home","text":"To build the docs pages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs docs/make.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or editing the docs live:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if we forget index.md like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"it will not build and serve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exup√©ry","category":"page"},{"location":"generated/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"This quickstart guide will help you get up and running with PiccoloQuantumObjects.jl.","category":"page"},{"location":"generated/quickstart/#Installation","page":"Quickstart","title":"Installation","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"using Pkg\nPkg.add(\"PiccoloQuantumObjects\")","category":"page"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart","title":"Basic Usage","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"using PiccoloQuantumObjects\nusing LinearAlgebra\nusing SparseArrays\nusing NamedTrajectories","category":"page"},{"location":"generated/quickstart/#Creating-a-Quantum-System","page":"Quickstart","title":"Creating a Quantum System","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define Hamiltonian components","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Specify time and control bounds","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"T_max = 10.0  # Maximum evolution time\ndrive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]  # Control bounds for each drive","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create the quantum system","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"system = QuantumSystem(H_drift, H_drives, T_max, drive_bounds)","category":"page"},{"location":"generated/quickstart/#Working-with-Quantum-States","page":"Quickstart","title":"Working with Quantum States","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create quantum states","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œà_ground = ket_from_string(\"g\", [2])  # Ground state","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œà_excited = ket_from_string(\"e\", [2])  # Excited state","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Calculate fidelity","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"fidelity(œà_ground, œà_excited)","category":"page"},{"location":"generated/quickstart/#Simulating-Evolution-(Rollouts)","page":"Quickstart","title":"Simulating Evolution (Rollouts)","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Initial state","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œà_init = ComplexF64[1.0, 0.0]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define control sequence","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"T = 10  # Number of time steps\ncontrols = rand(2, T)  # Random controls for two drives\nŒît = fill(0.1, T)  # Time step duration","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Perform rollout","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œàÃÉ_rollout = rollout(œà_init, controls, Œît, system)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Check final state fidelity","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œà_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(œà_init, œà_goal, controls, Œît, system)","category":"page"},{"location":"generated/quickstart/#Open-Quantum-Systems","page":"Quickstart","title":"Open Quantum Systems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Add dissipation operators","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"a = annihilate(2)\ndissipation_operators = [a'a, a]","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create open quantum system","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"open_system = OpenQuantumSystem(\n    H_drives,\n    T_max,\n    drive_bounds,\n    dissipation_operators=dissipation_operators\n)","category":"page"},{"location":"generated/quickstart/#Composite-Systems","page":"Quickstart","title":"Composite Systems","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create subsystems","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"sys1 = QuantumSystem([PAULIS[:X]], 10.0, [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], 10.0, [(-1.0, 1.0)])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define coupling","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"H_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create composite system","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"composite_sys = CompositeQuantumSystem(\n    H_coupling,\n    Matrix{ComplexF64}[],\n    [sys1, sys2],\n    10.0,\n    Float64[]\n)","category":"page"},{"location":"generated/quickstart/#Visualization","page":"Quickstart","title":"Visualization","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"PiccoloQuantumObjects.jl integrates with NamedTrajectories.jl for plotting trajectories.","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"using CairoMakie","category":"page"},{"location":"generated/quickstart/#Plotting-Controls-and-States","page":"Quickstart","title":"Plotting Controls and States","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create a trajectory with controls and states","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"T_plot = 50\ncontrols_plot = 0.5 * sin.(2œÄ * (1:T_plot) / T_plot)\nŒît_plot = fill(T_max / T_plot, T_plot)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Perform a rollout to get the state evolution","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"œàÃÉ_traj = rollout(œà_init, hcat(controls_plot, -controls_plot)', Œît_plot, system)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Create a NamedTrajectory for plotting","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"traj = NamedTrajectory(\n    (\n        œàÃÉ = œàÃÉ_traj,\n        a = hcat(controls_plot, -controls_plot)',\n        Œît = Œît_plot\n    );\n    timestep=:Œît,\n    controls=:a,\n    initial=(œàÃÉ = ket_to_iso(œà_init),),\n    goal=(œàÃÉ = ket_to_iso(œà_goal),)\n)","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Plot the trajectory","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(traj)","category":"page"},{"location":"generated/quickstart/#Plotting-State-Populations","page":"Quickstart","title":"Plotting State Populations","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Use transformations to plot populations directly from isomorphic states","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(\n    traj,\n    [:a],\n    transformations=[\n        :œàÃÉ => (œàÃÉ -> abs2.(iso_to_ket(œàÃÉ)))\n    ],\n    transformation_labels=[\"Populations\"]\n)","category":"page"},{"location":"generated/quickstart/#Next-Steps","page":"Quickstart","title":"Next Steps","text":"","category":"section"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"Explore the Quantum Systems manual for detailed system construction\nLearn about Quantum Objects for working with states and operators\nSee Rollouts for simulation and fidelity calculations\nUnderstand Isomorphisms for the underlying mathematical transformations","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/rollouts/#Rollouts-and-fidelity","page":"Rollouts","title":"Rollouts and fidelity","text":"","category":"section"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"using PiccoloQuantumObjects\nusing NamedTrajectories\nusing SparseArrays # for visualization\nusing LinearAlgebra","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"Rollouts are simulations of a quantum system. In a rollout, controls are integrated forward in time using the dynamics implied by a provided quantum systems. The defualt is to use zero-order hold integration to simulate the evolution‚Äì-that is, the controls are held constant between time steps. For quantum states, the Schr√∂dinger equation is used:","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"psi(t + Delta t) = expleft(-i H(mathbfa(t)) Delta tright) psi(t)","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"The visited states are collected into a matrix of size (2n, T), for the isomorphic Hilbert space dimension 2n and timesteps T.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"note: Note\nAll of the returned rollout are assumed to be real valued. It is helpful to use the appropriate isomorphisms to convert between real and complex quantum objects, and eachcol to iterate over the rollout columns.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"There are rollouts for each kind of quantum object: quantum states, unitary operators, and density operators.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"A fidelity function is also provided for each kind of quantum objectand a rollout fidelity function compares the final state of a rollout to a goal state.","category":"page"},{"location":"generated/rollouts/#Fidelity-functions","page":"Rollouts","title":"Fidelity functions","text":"","category":"section"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"The fidelity functions are used to measure how close two quantum states or operators are to each other.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"fidelity calculates the fidelity between two quantum states.\nunitary_fidelity calculates the fidelity between two unitary operators.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"State fidelity.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"œà = GATES.X * [1.0, 0.0]\nœà_goal = [0.0, 1.0]\nfidelity(œà, œà_goal)","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"Unitary fidelity of orthogonal operations.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"U = GATES.Y\nU_goal = GATES.X\nunitary_fidelity(U, U_goal)","category":"page"},{"location":"generated/rollouts/#Quantum-State-Rollouts","page":"Rollouts","title":"Quantum State Rollouts","text":"","category":"section"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"The rollout function simulates the evolution of a real valued quantum state under given controls and quantum system.","category":"page"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout","text":"rollout(\n    œàÃÉ_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    œà_init::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout(\n    inits::AbstractVector{<:AbstractVector},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\n\nRollout a quantum state œàÃÉ_init under the control controls for a time Œît using the system system.\n\nIf exp_vector_product is true, the integrator is expected to have a signature like the exponential action, expv. Otherwise, it is expected to have a signature like exp.\n\nTypes should allow for autodifferentiable controls and times.\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout_fidelity-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout_fidelity","text":"rollout_fidelity(\n    œàÃÉ_init::AbstractVector{<:Real},\n    œàÃÉ_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    œà_init::AbstractVector{<:Complex},\n    œà_goal::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem\n)\nrollout_fidelity(\n    trajectory::NamedTrajectory,\n    system::AbstractQuantumSystem\n)\n\nCalculate the fidelity between the final state of a rollout and a goal state.\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"The rollout is a matrix of size (2n, T).","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"T = 10\nœà_init = ComplexF64[1.0, 0.0]\ncontrols = rand(2, T)\nŒît = fill(0.1, T)\nsystem = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], 1.0, [(-1.0, 1.0), (-1.0, 1.0)])\nœàÃÉ_rollout = rollout(œà_init, controls, Œît, system)\nœàÃÉ_rollout |> size","category":"page"},{"location":"generated/rollouts/#Quantum-State-Rollout-Fidelity","page":"Rollouts","title":"Quantum State Rollout Fidelity","text":"","category":"section"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"States must be cast to complex for the rollout to know the difference between real and isomorphic states.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"œà_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(œà_init, œà_goal, controls, Œît, system)","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"warning: Warning\nDon't forget to convert the quantum state to the appropriate isomorphism before calculating the fidelity.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"fidelity(iso_to_ket(œàÃÉ_rollout[:, end]), œà_goal)","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"The initial state and goal are often inferred from the properly configured trajectory of a control problem.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"components = (œàÃÉ = zeros(Float64, size(œàÃÉ_rollout)), a = controls, Œît = Œît)\ntraj = NamedTrajectory(\n    components;\n    timestep=:Œît,\n    controls=:a,\n    initial=(œàÃÉ = ket_to_iso(œà_init),),\n    goal=(œàÃÉ = ket_to_iso(œà_goal),),\n)\nrollout_fidelity(traj, system)","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"note: Note\nThe rollout fidelity is not the same thing as the fidelity of the final trajectory state.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"fidelity(iso_to_ket(traj.œàÃÉ[:, end]), œà_goal)","category":"page"},{"location":"generated/rollouts/#Unitary-Rollouts","page":"Rollouts","title":"Unitary Rollouts","text":"","category":"section"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout","text":"unitary_rollout(\n    UÃÉ‚Éó_init::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\n\nRollout a isomorphic unitary operator UÃÉ‚Éó_init under the control controls for a time Œît using the system system.\n\nArguments\n\nUÃÉ‚Éó_init::AbstractVector{<:Real}: Initial unitary vector\ncontrols::AbstractMatrix{<:Real}: Control matrix\nŒît::AbstractVector: Time steps\nsystem::AbstractQuantumSystem: Quantum system\n\nKeyword Arguments\n\nshow_progress::Bool=false: Show progress bar\nintegrator::Function=expv: Integrator function\nexp_vector_product::Bool: Infer whether the integrator is an exponential-vector product\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.unitary_rollout_fidelity","text":"unitary_rollout_fidelity(\n    UÃÉ‚Éó_init::AbstractVector{<:Real},\n    UÃÉ‚Éó_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    UÃÉ‚Éó_goal::AbstractVector{<:Real},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_init::AbstractMatrix{<:Complex},\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    kwargs...\n)\nunitary_rollout_fidelity(\n    U_goal::EmbeddedOperator,\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::AbstractQuantumSystem;\n    subspace::AbstractVector{Int}=U_goal.subspace,\n    kwargs...\n)\nunitary_rollout_fidelity(\n    traj::NamedTrajectory,\n    sys::AbstractQuantumSystem;\n    kwargs...\n)\n\nCalculate the fidelity between the final state of a unitary rollout and a goal state.  If the initial unitary is not provided, the identity operator is assumed. If phases and phase_operators are provided, the free phase unitary fidelity is calculated.\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"UÃÉ‚Éó_rollout = unitary_rollout(controls, Œît, system)\nUÃÉ‚Éó_rollout |> size","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"Convert to unitary operators, and have a look at the initial unitary.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"iso_vec_to_operator.(eachcol(UÃÉ‚Éó_rollout[:, 1])) |> first","category":"page"},{"location":"generated/rollouts/#Open-Quantum-System-Rollouts","page":"Rollouts","title":"Open Quantum System Rollouts","text":"","category":"section"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout","text":"open_rollout(\n    œÅ‚Éó‚ÇÅ::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem;\n    kwargs...\n)\n\nRollout a quantum state œÅ‚Éó‚ÇÅ under the control controls for a time Œît\n\nArguments\n\nœÅ‚Éó‚ÇÅ::AbstractVector{<:Complex}: Initial state vector\ncontrols::AbstractMatrix{<:Real}: Control matrix\nŒît::AbstractVector: Time steps\nsystem::OpenQuantumSystem: Quantum system\n\nKeyword Arguments\n\nshow_progress::Bool=false: Show progress bar\nintegrator::Function=expv: Integrator function\nexp_vector_product::Bool: Infer whether the integrator is an exponential-vector product\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.open_rollout_fidelity-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.open_rollout_fidelity","text":"open_rollout_fidelity(\n    œÅ‚Éó‚ÇÅ::AbstractVector{<:Complex},\n    œÅ‚Éó‚ÇÇ::AbstractVector{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    œÅ‚ÇÅ::AbstractMatrix{<:Complex},\n    œÅ‚ÇÇ::AbstractMatrix{<:Complex},\n    controls::AbstractMatrix{<:Real},\n    Œît::AbstractVector,\n    system::OpenQuantumSystem\n)\nopen_rollout_fidelity(\n    traj::NamedTrajectory,\n    system::OpenQuantumSystem;\n    state_name::Symbol=:œÅ‚ÉóÃÉ,\n    control_name::Symbol=:a,\n    kwargs...\n)\n\nCalculate the fidelity between the final state of an open quantum system rollout and a goal state.\n\n\n\n\n\n","category":"function"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"Open rollouts require open quantum systems.","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"open_system = OpenQuantumSystem(system)\n\nœÅ_init = œà_init * œà_init'\nœÅÃÉ‚Éó_rollout = open_rollout(œÅ_init, controls, Œît, open_system)\nœÅÃÉ‚Éó_rollout |> size","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"","category":"page"},{"location":"generated/rollouts/","page":"Rollouts","title":"Rollouts","text":"This page was generated using Literate.jl.","category":"page"}]
}
