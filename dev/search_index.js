var documenterSearchIndex = {"docs":
[{"location":"generated/composite_quantum_systems/#Composite-Quantum-Systems","page":"Composite Quantum Systems","title":"Composite Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n‚äó = kron;\nnothing #hide","category":"section"},{"location":"generated/composite_quantum_systems/#Composite-quantum-systems","page":"Composite Quantum Systems","title":"Composite quantum systems","text":"A CompositeQuantumSystem is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space.\n\nsystem_1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsystem_2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nH_drift = PAULIS[:Z] ‚äó PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, Matrix{ComplexF64}[], [system_1, system_2], Float64[]);\nnothing #hide\n\nThe drift Hamiltonian is the ZZ coupling.\n\nget_drift(system) |> sparse\n\nThe drives are the X and Y operators on the first and second subsystems.\n\ndrives = get_drives(system)\ndrives[1] |> sparse\n\ndrives[2] |> sparse","category":"section"},{"location":"generated/composite_quantum_systems/#The-lift_operator-function","page":"Composite Quantum Systems","title":"The lift_operator function","text":"To lift operators acting on a subsystem into the full Hilbert space, use lift_operator.\n\nCreate an a + a' operator acting on the 1st subsystem of a qutrit and qubit system.\n\nsubspace_levels = [3, 2]\nlift_operator(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse\n\nCreate IXI operator on the 2nd qubit in a 3-qubit system.\n\nlift_operator(PAULIS[:X], 2, 3) .|> real |> sparse\n\nCreate an XX operator acting on qubits 3 and 4 in a 4-qubit system.\n\nlift_operator([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse\n\nWe can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems.\n\n#_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift_operator(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse\n\nLift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit.\n\nlift_operator(GATES[:CX], [1, 3], 3) .|> real |> sparse\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/composite_quantum_systems/#PiccoloQuantumObjects.LiftedOperators.lift_operator-generated-composite_quantum_systems","page":"Composite Quantum Systems","title":"PiccoloQuantumObjects.LiftedOperators.lift_operator","text":"lift_operator(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift_operator(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift_operator(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"generated/variational_quantum_systems/#Variational-Quantum-Systems","page":"Variational Quantum Systems","title":"Variational Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization","category":"section"},{"location":"generated/variational_quantum_systems/#Variational-Quantum-Systems-2","page":"Variational Quantum Systems","title":"Variational Quantum Systems","text":"The VariationalQuantumSystem type is used for sensitivity and robustness analysis of quantum control protocols. It allows exploring how the dynamics change under perturbations to the Hamiltonian.\n\nVariational systems are parameterized by variational operators that represent directions of uncertainty or perturbation in the system:\n\nH_textperturbed(alpha) = H(alpha) + sum_i epsilon_i H_textvar^(i)\n\nwhere alpha represents the control parameters and epsilon_i are perturbation magnitudes.\n\nCreate a variational system with X and Y as both drives and variational directions.\n\nH_drift = 0.0 * PAULIS[:Z]  # No drift\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nH_vars = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nvarsys = VariationalQuantumSystem(H_drift, H_drives, H_vars, drive_bounds)\n\nThe system has 2 drives and 2 variational operators.\n\nvarsys.n_drives\n\nlength(varsys.G_vars)\n\nvarsys.drive_bounds","category":"section"},{"location":"generated/variational_quantum_systems/#Variational-operators","page":"Variational Quantum Systems","title":"Variational operators","text":"Variational systems compute the isomorphic generator G along with variational generators G_vars for sensitivity analysis. These can be used to study how the system dynamics change under perturbations.\n\nEvaluate the generator at specific control values.\n\ncontrol_params = [1.0, 0.5]\nG = varsys.G(control_params)\nG |> sparse\n\nGet the first variational generator.\n\nG_var_1 = varsys.G_vars[1](control_params)\nG_var_1 |> sparse\n\nGet the second variational generator.\n\nG_var_2 = varsys.G_vars[2](control_params)\nG_var_2 |> sparse","category":"section"},{"location":"generated/variational_quantum_systems/#Use-cases","page":"Variational Quantum Systems","title":"Use cases","text":"Variational quantum systems are particularly useful for:\n\nSensitivity analysis: Understanding how control imperfections affect gate fidelities\nRobustness optimization: Designing controls that are robust to parameter uncertainties\nError modeling: Incorporating known sources of systematic error in control optimization\n\nnote: No drift constructor\nYou can create a variational system with no drift Hamiltonian by omitting H_drift:varsys = VariationalQuantumSystem(H_drives, H_vars, drive_bounds)\n\nCreate a variational system with only drive and variational operators.\n\nvarsys_nodrift = VariationalQuantumSystem([PAULIS[:X], PAULIS[:Y]], [PAULIS[:Z]], [1.0, 1.0])\nvarsys_nodrift.n_drives\n\nlength(varsys_nodrift.G_vars)","category":"section"},{"location":"generated/variational_quantum_systems/#Functional-variational-systems","page":"Variational Quantum Systems","title":"Functional variational systems","text":"For more complex scenarios, variational systems can be constructed from functions rather than explicit matrix operators:\n\nCreate a variational system using Hamiltonian functions.\n\nH_func = a -> a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nH_var_funcs = [\n    a -> a[1] * PAULIS[:X],  # Sensitivity to X scaling\n    a -> PAULIS[:Z]           # Sensitivity to Z perturbation\n]\nvarsys_func = VariationalQuantumSystem(H_func, H_var_funcs, 2, [1.0, 1.0])\n\nThe functional system behaves similarly.\n\nvarsys_func.n_drives\n\nlength(varsys_func.G_vars)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/variational_quantum_systems/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem-generated-variational_quantum_systems","page":"Variational Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.\n\nVariational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nG_vars::AbstractVector{<:Function}: Variational generator functions, one for each perturbation direction\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also QuantumSystem, OpenQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"generated/isomorphisms/#Isomorphisms","page":"Isomorphisms","title":"Isomorphisms","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n\nLinear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the QuantumSystem type to perform quantum dynamics.","category":"section"},{"location":"generated/isomorphisms/#Quantum-state-isomorphisms","page":"Isomorphisms","title":"Quantum state isomorphisms","text":"ket_to_iso is the real isomorphism of a quantum state œà ‚àà ‚ÑÇ‚Åø\niso_to_ket is the inverse isomorphism of a real vector œàÃÉ ‚àà ‚Ñù¬≤‚Åø\n\nœà = [1; 2] + im * [3; 4]\nœàÃÉ = ket_to_iso(œà)\n\niso_to_ket(œàÃÉ)","category":"section"},{"location":"generated/isomorphisms/#Quantum-operator-isomorphisms","page":"Isomorphisms","title":"Quantum operator isomorphisms","text":"We often need to convert a complex matrix U to a real vector UÃÉ‚Éó. We provoide the following isomorphisms to convert between the two representations.\n\niso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù})\noperator_to_iso_vec(U::AbstractVector{‚ÑÇ})\niso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù})\niso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù})\niso_operator_to_operator(UÃÉ::AbstractMatrix{‚Ñù})\noperator_to_iso_operator(U::AbstractMatrix{‚ÑÇ})\n\nIn additon, we provide mat(x::AbstractVector) to convert a vector x into a square matrix, as the inverse to Base's vec.\n\nJulia uses column-major order.\n\nU = [1 5; 2 6] + im * [3 7; 4 8]\nUÃÉ‚Éó = operator_to_iso_vec(U)\n\niso_vec_to_operator(UÃÉ‚Éó)","category":"section"},{"location":"generated/isomorphisms/#Density-matrix-isomorphisms","page":"Isomorphisms","title":"Density matrix isomorphisms","text":"The isomorphisms for density matrices are:\n\ndensity_to_iso_vec(œÅ::AbstractMatrix{‚ÑÇ})\niso_vec_to_density(œÅÃÉ::AbstractVector{‚Ñù})\n\nwarning: Warning\nThe isomorphism density_to_iso_vec is not the same as operator_to_iso_vec.\n\nœÅ = [1 2; 3 4] + im * [5 6; 7 8]\nœÅÃÉ‚Éó = density_to_iso_vec(œÅ)","category":"section"},{"location":"generated/isomorphisms/#Quantum-dynamics-isomorphisms","page":"Isomorphisms","title":"Quantum dynamics isomorphisms","text":"The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the QuantumSystem type.\n\nThe Isomorphisms.iso isomorphism of a Hamiltonian H is:\n\ntextiso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nHence, the generator Isomorphisms.G associated to a Hamiltonian H is:\n\nG(H) = textiso(- i widetildeH) = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"lib/#Quantum-Systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/#Gates","page":"Library","title":"Gates","text":"","category":"section"},{"location":"lib/#Embedded-Operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/#Isomorphisims","page":"Library","title":"Isomorphisims","text":"","category":"section"},{"location":"lib/#Quantum-Object-Utilities","page":"Library","title":"Quantum Object Utilities","text":"","category":"section"},{"location":"lib/#Quantum-System-Utilities","page":"Library","title":"Quantum System Utilities","text":"","category":"section"},{"location":"lib/#Rollouts","page":"Library","title":"Rollouts","text":"","category":"section"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem <: AbstractQuantumSystem\n\nA composite quantum system consisting of multiple subsystems with optional coupling terms.\n\nComposite systems represent multiple quantum subsystems (e.g., multiple qubits or oscillators) that may be coupled together. Each subsystem's Hamiltonians are automatically lifted to the  full tensor product space, and subsystem drives are appended to any coupling drives.\n\nFields\n\nH::Function: The total Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The total drift Hamiltonian including subsystem drifts and couplings\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: All drive Hamiltonians (coupling drives + subsystem drives)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control\nn_drives::Int: Total number of control drives\nlevels::Int: Total dimension of the composite system (product of subsystem dimensions)\nsubsystem_levels::Vector{Int}: Dimensions of each subsystem\nsubsystems::Vector{QuantumSystem}: The individual quantum subsystems\n\nSee also LiftedOperators, lift_operator.\n\nExample\n\n# Two qubits with ZZ coupling\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConstruct a CompositeQuantumSystem with coupling drift and drive terms.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian (in full tensor product space)\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (subsystem bounds are inherited). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe total drift includes both the coupling drift and all subsystem drifts (automatically lifted). The total drives include coupling drives followed by all subsystem drives (automatically lifted).\n\nExample\n\nsys1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drift\ncsys = CompositeQuantumSystem(g12, Matrix{ComplexF64}[], [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Tuple{AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with no coupling terms (neither drift nor drives).\n\nUse this when you have independent subsystems that you want to represent in a single composite space, but without any direct coupling between them.\n\nArguments\n\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ncsys = CompositeQuantumSystem([sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drift::AbstractMatrix,\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drift but no coupling drives.\n\nArguments\n\nH_drift::AbstractMatrix: Coupling drift Hamiltonian\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives (typically empty). Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])  # coupling drift\ncsys = CompositeQuantumSystem(H_coupling, [sys1, sys2], Float64[])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:QuantumSystem}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem(\n    H_drives::AbstractVector{<:AbstractMatrix},\n    subsystems::AbstractVector{<:QuantumSystem},\n    drive_bounds::DriveBounds\n)\n\nConvenience constructor for a composite system with coupling drives but no coupling drift.\n\nArguments\n\nH_drives::AbstractVector{<:AbstractMatrix}: Coupling drive Hamiltonians\nsubsystems::AbstractVector{<:QuantumSystem}: Vector of subsystems to compose\ndrive_bounds::DriveBounds: Drive bounds for the coupling drives. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [1.0])\nsys2 = QuantumSystem([PAULIS[:Y]], [1.0])\ng12 = 0.1 * kron(PAULIS[:X], PAULIS[:X])  # coupling drive\ncsys = CompositeQuantumSystem([g12], [sys1, sys2], [1.0])  # symmetric bound\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.DriveBounds","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.DriveBounds","text":"DriveBounds\n\nType alias for drive amplitude bounds input. Bounds can be specified as:\n\nA tuple (lower, upper) for asymmetric bounds\nA scalar value which is interpreted as symmetric bounds (-value, value)\n\nExamples\n\ndrive_bounds = [(-1.0, 1.0), 0.5, (-0.3, 0.7)]\n# Interpreted as: [(-1.0, 1.0), (-0.5, 0.5), (-0.3, 0.7)]\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number};\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::DriveBounds;\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    H::Function, \n    drive_bounds::DriveBounds;\n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[],\n    time_dependent::Bool=false\n)\nOpenQuantumSystem(\n    system::QuantumSystem; \n    dissipation_operators::Vector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[]\n)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.\n\nDrive Bounds\n\nThe drive_bounds parameter can be:\n\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Tuple{QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(system::QuantumSystem; dissipation_operators=[])\n\nConstruct an OpenQuantumSystem from a QuantumSystem by adding dissipation operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drift; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with only drift (no drives).\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{F}, Tuple{F, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where {F<:Function, ‚ÑÇ<:Number}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H::Function, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem from a Hamiltonian function.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(H_drives, drive_bounds; dissipation_operators=[], time_dependent=false)\n\nConstruct an OpenQuantumSystem with no drift.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians (control-dependent components)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence beyond control modulation\nglobal_params::NamedTuple: Global parameters that the Hamiltonian may depend on (e.g., (Œ¥=0.5, Œ©=1.0))\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Tuple{AbstractMatrix{<:Number}, Vector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::Vector{<:AbstractMatrix{<:Number}},\n    drive_bounds::Vector{<:Union{Tuple{Float64, Float64}, Float64}};\n    time_dependent::Bool=false\n)\n\nConstruct a QuantumSystem from drift and drive Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians, one for each control\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if using time-dependent modulation (typically handled at a higher level)\nglobal_params::NamedTuple=NamedTuple(): Global parameters stored with the system. Note: for matrix-based systems, matrices are fixed at construction, so globalparams are mainly for storage/bookkeeping and later updates via `updateglobal_params!`\n\nThe resulting Hamiltonian is: H(u, t) = Hdrift + Œ£·µ¢ u·µ¢ * Hdrives[i]\n\nExample\n\nsys = QuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Tuple{Function, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H::Function, drive_bounds::Vector; time_dependent::Bool=false)\n\nConstruct a QuantumSystem from a Hamiltonian function.\n\nArguments\n\nH::Function: Hamiltonian function with signature (u, t) -> H(u, t) where u is the control vector and t is time\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nKeyword Arguments\n\ntime_dependent::Bool=false: Set to true if the Hamiltonian has explicit time dependence (e.g., cos(œât) modulation)\nglobal_params::NamedTuple=NamedTuple(): Global parameters to store with the system. For function-based systems, access these via closure in your H function: H(u, t) = global_params.Œ¥ * ... where global_params is captured from outer scope.\n\nExample\n\n# Define a time-dependent Hamiltonian\nH = (u, t) -> PAULIS[:Z] + u[1] * cos(œâ * t) * PAULIS[:X]\nsys = QuantumSystem(H, [(-1.0, 1.0)]; time_dependent=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::AbstractMatrix; time_dependent::Bool=false)\n\nConvenience constructor for a system with only a drift Hamiltonian (no drives).\n\nExample\n\nsys = QuantumSystem(PAULIS[:Z])\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-Union{Tuple{‚ÑÇ}, Tuple{Vector{<:AbstractMatrix{‚ÑÇ}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drives::Vector{<:AbstractMatrix}, drive_bounds::Vector; time_dependent::Bool=false)\n\nConvenience constructor for a system with no drift Hamiltonian (H_drift = 0).\n\nArguments\n\nH_drives::Vector{<:AbstractMatrix}: Vector of drive Hamiltonians\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nExample\n\n# Using scalars for symmetric bounds\nsys = QuantumSystem([PAULIS[:X], PAULIS[:Y]], [1.0, 1.0])\n# Equivalent to: drive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing variational quantum dynamics, used for sensitivity and robustness analysis.\n\nVariational systems allow exploring how the dynamics change under perturbations to the Hamiltonian. The variational operators represent directions of uncertainty or perturbation in the system.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nG::Function: The isomorphic generator function: (u, t) -> G(u, t)\nG_vars::AbstractVector{<:Function}: Variational generator functions, one for each perturbation direction\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\n\nSee also QuantumSystem, OpenQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}, AbstractVector{<:AbstractMatrix{<:Number}}, Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.VariationalQuantumSystem","text":"VariationalQuantumSystem(\n    H_drift::AbstractMatrix,\n    H_drives::AbstractVector{<:AbstractMatrix},\n    H_vars::AbstractVector{<:AbstractMatrix},\n    drive_bounds::DriveBounds\n)\n\nConstruct a VariationalQuantumSystem from drift, drive, and variational Hamiltonian terms.\n\nArguments\n\nH_drift::AbstractMatrix: The drift (time-independent) Hamiltonian\nH_drives::AbstractVector{<:AbstractMatrix}: Vector of drive Hamiltonians for control\nH_vars::AbstractVector{<:AbstractMatrix}: Vector of variational Hamiltonians representing perturbation directions\ndrive_bounds::DriveBounds: Drive amplitude bounds for each control. Can be:\nTuples (lower, upper) for asymmetric bounds\nScalars which are interpreted as symmetric bounds (-value, value)\n\nThe variational operators allow sensitivity analysis by exploring how dynamics change under perturbations: Hperturbed = H + Œ£·µ¢ Œµ·µ¢ * Hvars[i]\n\nExample\n\nvarsys = VariationalQuantumSystem(\n    PAULIS[:Z],                    # drift\n    [PAULIS[:X], PAULIS[:Y]],      # drives\n    [PAULIS[:X]],                  # variational perturbations\n    [1.0, 1.0]                     # symmetric bounds: [(-1.0, 1.0), (-1.0, 1.0)]\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","text":"get_drift(sys::AbstractQuantumSystem)\n\nReturns the drift Hamiltonian of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","text":"get_drives(sys::AbstractQuantumSystem)\n\nReturns the drive Hamiltonians of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.is_hermitian-Tuple{AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.is_hermitian","text":"is_hermitian(H::AbstractMatrix; tol=1e-10)\n\nCheck if a matrix is Hermitian within a tolerance.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.normalize_drive_bounds-Tuple{Vector{<:Union{Float64, Tuple{Float64, Float64}}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.normalize_drive_bounds","text":"normalize_drive_bounds(bounds::DriveBounds)\n\nConvert drive bounds to a consistent tuple format. Scalar values are converted to  symmetric bounds around zero: b becomes (-b, b).\n\nArguments\n\nbounds::DriveBounds: Input bounds, can be tuples or scalars\n\nReturns\n\nVector{Tuple{Float64, Float64}}: Normalized bounds as tuples\n\nExamples\n\n# All scalars (symmetric bounds)\nnormalize_drive_bounds([1.0, 1.5, 0.5])\n# Returns: [(-1.0, 1.0), (-1.5, 1.5), (-0.5, 0.5)]\n\n# All tuples (asymmetric bounds)\nnormalize_drive_bounds([(-2.0, 3.0), (-1.0, 1.0)])\n# Returns: [(-2.0, 3.0), (-1.0, 1.0)]\n\n# Mixed types (requires explicit type annotation)\nnormalize_drive_bounds(Union{Float64, Tuple{Float64,Float64}}[1.0, (-2.0, 3.0)])\n# Returns: [(-1.0, 1.0), (-2.0, 3.0)]\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Gates.GATES","page":"Library","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#PiccoloQuantumObjects.Gates.PAULIS","page":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","text":"The 2√ó2 Pauli matrics and identity.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","text":"AbstractPiccoloOperator\n\nUnion type for operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...)\n\nEmbed the subspace_operator into a quantum system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","text":"get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of the quantum system with an excitation restriction.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","text":"get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the leakage in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","text":"get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the states that are outside of the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH, i.e. G(H) = textiso(-iH).\n\nSee also Isomorphisms.iso, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Real})\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H.\n\nSee also Isomorphisms.iso, Isomorphisms.G.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","text":"ad_vec(H::AbstractMatrix{‚ÑÇ}; anti::Bool=false) where ‚ÑÇ <: Number\n\nReturns the vectorized adjoint action of a matrix H:\n\ntextad_vec(H) = mqty(1  0  0  1) otimes H - (-1)^textanti mqty(0  1  1  0) otimes H^*\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.bloch_to_ket-Union{Tuple{AbstractVector{R}}, Tuple{R}} where R<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.bloch_to_ket","text":"bloch_to_ket(v::AbstractVector{<:Real}; digits=6)\n\nConvert a Bloch vector to a ket (up to global phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","text":"density_to_iso_vec(œÅ::AbstractMatrix{<:Number})\n\nReturns the isomorphism œÅ‚ÉóÃÉ = ket_to_iso(vec(œÅ)) of a density matrix œÅ\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","text":"iso(H::AbstractMatrix{<:Number})\n\nReturns the isomorphism of H:\n\niso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde  indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nSee also Isomorphisms.G, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","text":"iso_D(L::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nReturns the isomorphic representation of the Lindblad dissipator L.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(UÃÉ::AbstractMatrix{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real matrix UÃÉ representing an isomorphism operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","text":"iso_operator_to_operator(UÃÉ)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","text":"iso_to_ket(œàÃÉ::AbstractVector{<:Real})\n\nConvert a real isomorphism vector œàÃÉ into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","text":"iso_vec_to_density(œÅ‚ÉóÃÉ::AbstractVector{<:Real})\n\nReturns the density matrix œÅ from its isomorphism œÅ‚ÉóÃÉ\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a real matrix representing an isomorphism operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{‚Ñù}}, Tuple{‚Ñù}} where ‚Ñù<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(UÃÉ‚Éó::AbstractVector{‚Ñù}) where ‚Ñù <: Real\n\nConvert a real vector UÃÉ‚Éó into a complex matrix representing an operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_bloch-Tuple{AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_bloch","text":"ket_to_bloch(œà::AbstractVector{<:Number})\n\nConvert a ket to a Bloch vector representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","text":"ket_to_iso(œà::AbstractVector{<:Number})\n\nConvert a ket vector œà into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","text":"operator_to_iso_operator(U)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{‚ÑÇ}}, Tuple{‚ÑÇ}} where ‚ÑÇ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{‚ÑÇ}) where ‚ÑÇ <: Number\n\nConvert a complex matrix U representing an operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.var_G-Union{Tuple{‚Ñù2}, Tuple{‚Ñù1}, Tuple{AbstractMatrix{‚Ñù1}, AbstractVector{<:AbstractMatrix{‚Ñù2}}}} where {‚Ñù1<:Real, ‚Ñù2<:Real}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.var_G","text":"var_G(G::AbstractMatrix{<:Real}, G_vars::AbstractVector{<:AbstractMatrix{<:Real}})\n\nReturns the variational generator of G with variational derivatives, G_vars.\n\nThe variational generator is \n\ntextvar_G(G G_a G_b) = mqty( G  0  0  G_a  G  0  G_b  0  G )\n\nwhere G is the isomorphism of a Hamiltonian and G_a and G_b are the variational  derivatives of G for parameters a and b, respectively.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for an n-dimensional system with a given radius. The smaller the radius, the closer the matrix will be to the identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 3, :i => 4, :j => 5, :k => 6, :l => 7),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","text":"operator_from_string(operator::String; lookup=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent-Tuple{AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_linearly_dependent","text":"is_linearly_dependent(M::AbstractMatrix; eps=eps(Float32), verbose=true)\n\nCheck if the columns of the matrix M are linearly dependent.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","text":"operator_algebra(generators; kwargs...)\n\nCompute the Lie algebra basis for the given generators.\n\nArguments\n\ngenerators::Vector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nreturn_layers::Bool=false: return the Lie tree layers\nnormalize::Bool=false: normalize the basis\nverbose::Bool=false: print information\nremove_trace::Bool=true: remove trace from generators\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's drive_bounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Library","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts._update_system!","page":"Library","title":"PiccoloQuantumObjects.Rollouts._update_system!","text":"_update_system!(qtraj, sys::QuantumSystem)\n\nInternal method to update the system field in a quantum trajectory. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.extract_globals","page":"Library","title":"PiccoloQuantumObjects.Rollouts.extract_globals","text":"extract_globals(traj::NamedTrajectory, names::Vector{Symbol}=Symbol[])\n\nExtract global variables from trajectory as a NamedTuple for easy access. If names is empty, extracts all global variables.\n\nExample\n\ntraj = NamedTrajectory(...; global_data=[0.5, 1.0], global_components=(Œ¥=1:1, Œ©=2:2))\ng = extract_globals(traj)  # (Œ¥ = 0.5, Œ© = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","text":"fidelity(œÅ::AbstractMatrix{<:Number}, œÅ_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between two density matrices œÅ and œÅ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.fidelity-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.fidelity","text":"fidelity(œà::AbstractVector{<:Number}, œà_goal::AbstractVector{<:Number})\n\nCalculate the fidelity between two quantum states œà and œà_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.rollout","page":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout","text":"rollout(qtraj, args...; kwargs...)\n\nRoll out a quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.rollout!","page":"Library","title":"PiccoloQuantumObjects.Rollouts.rollout!","text":"rollout!(qtraj, args...; kwargs...)\n\nIn-place rollout of quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.unitary_fidelity-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.unitary_fidelity","text":"unitary_fidelity(U::AbstractMatrix{<:Number}, U_goal::AbstractMatrix{<:Number})\n\nCalculate the fidelity between unitary operators U and U_goal in the subspace.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Rollouts.update_global_params!-Tuple{Any, Any}","page":"Library","title":"PiccoloQuantumObjects.Rollouts.update_global_params!","text":"update_global_params!(qtraj, traj::NamedTrajectory)\n\nUpdate the global parameters in the quantum trajectory's system with the optimized values from the NamedTrajectory after optimization. Handles immutable QuantumSystem by reconstructing with updated global_params NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"generated/open_quantum_systems/#Open-Quantum-Systems","page":"Open Quantum Systems","title":"Open Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization","category":"section"},{"location":"generated/open_quantum_systems/#Open-quantum-systems","page":"Open Quantum Systems","title":"Open quantum systems","text":"We can construct an OpenQuantumSystem with Lindblad dynamics, enabling a user to pass a list of dissipation operators.\n\nAdd a dephasing and annihilation error channel.\n\nH_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\ndrive_bounds = [(-1.0, 1.0)]\nsystem = OpenQuantumSystem(H_drives, drive_bounds, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse\n\nsystem.dissipation_operators[2] |> sparse\n\nwarning: Warning\nThe Hamiltonian part system.H excludes the Lindblad operators. This is also true for functions that report properties of system.H, such as get_drift, get_drives, and is_reachable.\n\nget_drift(system) |> sparse\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/open_quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-open_quantum_systems","page":"Open Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem <: AbstractQuantumSystem\n\nA struct for storing open quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t)\nùí¢::Function: The Lindbladian generator function: u -> ùí¢(u)\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds\nn_drives::Int: The number of control drives\nlevels::Int: The number of levels in the system\ndissipation_operators::Vector{SparseMatrixCSC{ComplexF64, Int}}: The dissipation operators\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence\n\nSee also QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_objects/#Quantum-Objects","page":"Quantum Objects","title":"Quantum Objects","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n‚äó = kron;\nnothing #hide\n\nQuantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices.","category":"section"},{"location":"generated/quantum_objects/#Quantum-states","page":"Quantum Objects","title":"Quantum states","text":"We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state g, excited state e, etc.).\n\nGround state in a 2-level system.\n\nket_from_string(\"g\", [2])\n\nSuperposition state coupled to a ground state in two 2-level systems.\n\nket_from_string(\"(g+e)g\", [2,2])\n\n|01‚ü© in a 2-qubit system.\n\nket_from_bitstring(\"01\")","category":"section"},{"location":"generated/quantum_objects/#Quantum-operators","page":"Quantum Objects","title":"Quantum operators","text":"Frequently used operators are provided in PAULIS and GATES.\n\nQuantum operators can also be constructed from strings.\n\noperator_from_string(\"X\")\n\noperator_from_string(\"XZ\")\n\nAnnihilation and creation operators are provided for oscillator systems.\n\na = annihilate(3)\n\na‚Å∫ = create(3)\n\na'a","category":"section"},{"location":"generated/quantum_objects/#Random-operators","page":"Quantum Objects","title":"Random operators","text":"The haar_random function draws random unitary operators according to the Haar measure.\n\nhaar_random(3)\n\nIf we want to generate random operations that are close to the identity, we can use the haar_identity function.\n\nhaar_identity(2, 0.1)\n\nA smaller radius means the random operator is closer to the identity.\n\nhaar_identity(2, 0.01)","category":"section"},{"location":"generated/quantum_objects/#Embedded-operators","page":"Quantum Objects","title":"Embedded operators","text":"Sometimes we want to embed a quantum operator into a larger Hilbert space, mathcalH, which we decompose into subspace and leakage components:\n\n    mathcalH = mathcalH_textsubspace oplus mathcalH_textleakage\n\nIn quantum computing, the computation is encoded in a subspace, while the remaining leakage states should be avoided.","category":"section"},{"location":"generated/quantum_objects/#The-embed-and-unembed-functions","page":"Quantum Objects","title":"The embed and unembed functions","text":"The embed function allows to embed a quantum operator in a larger Hilbert space.\n\nThe unembed function allows to unembed a quantum operator from a larger Hilbert space.\n\nEmbed a two-level X gate into a multilevel system.\n\nlevels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels)\n\nUnembed to retrieve the original operator.\n\nX_original = unembed(X_embedded, subspace_indices)","category":"section"},{"location":"generated/quantum_objects/#The-EmbeddedOperator-type","page":"Quantum Objects","title":"The EmbeddedOperator type","text":"The EmbeddedOperator type stores information about an operator embedded in the subspace of a larger quantum system.\n\nWe construct an embedded operator in the same manner as the embed function.\n\nEmbed an X gate in the first qubit's subspace within two 3-level systems.\n\ngate = GATES[:X] ‚äó GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels)\n\nShow the full operator.\n\nembedded_operator.operator .|> real |> sparse\n\nGet the original operator back.\n\nunembed(embedded_operator) .|> real |> sparse\n\nEmbedded operators for composite systems are also supported.\n\nThis is a two step process.\n\nThe provided subspace operator is lift_operator-ed  from the subsystem_indices where  it is defined into the space spanned by the composite system's subspaces.\nThe lifted operator is embedded into the full Hilbert space spanned by the  subsystem_levels.\n\nEmbed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2.\n\nsubsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse","category":"section"},{"location":"generated/quantum_objects/#Subspace-and-leakage-indices","page":"Quantum Objects","title":"Subspace and leakage indices","text":"","category":"section"},{"location":"generated/quantum_objects/#The-get_subspace_indices-function","page":"Quantum Objects","title":"The get_subspace_indices function","text":"The get_subspace_indices function is a convenient way to get the indices of a subspace in a larger quantum system.\n\nIts dual function is get_leakage_indices.\n\nget_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect\n\nComposite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems.\n\nget_subspace_indices([1:2, 1:2], [3, 3])\n\nQubits are assumed if the indices are not provided.\n\nget_subspace_indices([3, 3])\n\nget_leakage_indices([3, 3])","category":"section"},{"location":"generated/quantum_objects/#Excitation-number-restrictions","page":"Quantum Objects","title":"Excitation number restrictions","text":"Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems:\n\nget_enr_subspace_indices(1, [3, 3])","category":"section"},{"location":"generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","page":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","text":"For isomorphic operators, the get_iso_vec_subspace_indices function can be used to find the appropriate vector indices of the equivalent operator subspace. See also, Isomorphisms#Quantum-operator-isomorphisms.\n\nIts dual function is get_iso_vec_leakage_indices, which by default only returns the leakage indices of the blocks:\n\nmathcalH_textsubspace otimes mathcalH_textsubspacequad\nmathcalH_textsubspace otimes mathcalH_textleakagequad\nmathcalH_textleakage otimes mathcalH_textsubspace\n\nallowing for leakage-suppressing code to disregard the uncoupled pure-leakage space.\n\nget_iso_vec_subspace_indices(1:2, 3)\n\nwithout_pure_leakage = get_iso_vec_leakage_indices(1:2, 3)\n\nShow the pure-leakage indices.\n\nwith_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage)\n\nThe pure-leakage indices can grow quickly!\n\nwithout_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1‚ü©.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1‚ü©.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\nembed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling matrix[subspace, subspace].\n\n\n\n\n\nunembed(embedded_op::EmbeddedOperator)\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\nunembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger quantum system.\n\nFields\n\noperator::Matrix{<:Number}: Embedded operator of size   prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded.\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)\nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems_base/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n‚äó = kron;\nnothing #hide","category":"section"},{"location":"generated/quantum_systems_base/#Quantum-Systems-2","page":"Quantum Systems","title":"Quantum Systems","text":"The QuantumSystem type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians,\n\nH(u t) = H_textdrift + sum_i u_i H_textdrives^(i)\n\nwhere u is the control vector and t is time.\n\nQuantumSystem's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. All systems require explicit specification of drive_bounds (control bounds).\n\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\ndrive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]\nsystem = QuantumSystem(H_drift, H_drives, drive_bounds)\n\nu_controls = [1.0, 0.0]\nt = 0.0\nsystem.H(u_controls, t)\n\nTo extract the drift and drive Hamiltonians from a QuantumSystem, use the get_drift and get_drives functions.\n\nget_drift(system) |> sparse\n\nGet the X drive.\n\ndrives = get_drives(system)\ndrives[1] |> sparse\n\nAnd the Y drive.\n\ndrives[2] |> sparse\n\nnote: Note\nWe can also construct a QuantumSystem directly from a Hamiltonian function. The function must accept (u, t) arguments where u is the control vector and t is time.\n\nH(u, t) = PAULIS[:Z] + u[1] * PAULIS[:X] + u[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, [(-1.0, 1.0), (-1.0, 1.0)]; time_dependent=true)\nsystem.H([1.0, 0.0], 0.0) |> sparse","category":"section"},{"location":"generated/quantum_systems_base/#Reachability-tests","page":"Quantum Systems","title":"Reachability tests","text":"Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the is_reachable function.\n\nY can be reached by commuting Z and X.\n\nsystem = QuantumSystem(PAULIS[:Z], [PAULIS[:X]], [(-1.0, 1.0)])\nis_reachable(PAULIS[:Y], system)\n\nY cannot be reached by X alone.\n\nsystem = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nis_reachable(PAULIS[:Y], system)","category":"section"},{"location":"generated/quantum_systems_base/#Direct-sums","page":"Quantum Systems","title":"Direct sums","text":"The direct sum of two quantum systems is constructed with the direct_sum function.\n\nCreate a pair of non-interacting qubits.\n\nsystem_1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], [(-1.0, 1.0), (-1.0, 1.0)])\nsystem_2 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], [(-1.0, 1.0), (-1.0, 1.0)])\nsystem = direct_sum(system_1, system_2)\nget_drift(system) |> sparse\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/quantum_systems_base/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems_base","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems_base/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems_base","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem <: AbstractQuantumSystem\n\nA struct for storing quantum dynamics.\n\nFields\n\nH::Function: The Hamiltonian function: (u, t) -> H(u, t), where u is the control vector and t is time\nG::Function: The isomorphic generator function: (u, t) -> G(u, t), including the Hamiltonian mapped to superoperator space\nH_drift::SparseMatrixCSC{ComplexF64, Int}: The drift Hamiltonian (time-independent component)\nH_drives::Vector{SparseMatrixCSC{ComplexF64, Int}}: The drive Hamiltonians (control-dependent components)\ndrive_bounds::Vector{Tuple{Float64, Float64}}: Drive amplitude bounds for each control (lower, upper)\nn_drives::Int: The number of control drives in the system\nlevels::Int: The number of levels (dimension) in the system\ntime_dependent::Bool: Whether the Hamiltonian has explicit time dependence beyond control modulation\nglobal_params::NamedTuple: Global parameters that the Hamiltonian may depend on (e.g., (Œ¥=0.5, Œ©=1.0))\n\nSee also OpenQuantumSystem, VariationalQuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems_base/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems_base","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\nis_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems_base/#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems_base","page":"Quantum Systems","title":"PiccoloQuantumObjects.DirectSums.direct_sum","text":"direct_sum(A::AbstractMatrix, B::AbstractMatrix)\n\nReturns the direct sum of two matrices.\n\n\n\n\n\ndirect_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)\n\nReturns the direct sum of two sparse matrices.\n\n\n\n\n\ndirect_sum(AÃÉ‚Éó::AbstractVector, BÃÉ‚Éó::AbstractVector)\n\nReturns the direct sum of two iso_vec operators.\n\n\n\n\n\ndirect_sum(sys1::QuantumSystem, sys2::QuantumSystem)\n\nReturns the direct sum of two QuantumSystem objects.\n\nConstructs a new system where the Hilbert space is the direct sum of the two input systems: H = H‚ÇÅ ‚äï H‚ÇÇ = [H‚ÇÅ  0 ]                [0   H‚ÇÇ]\n\nBoth systems must have the same number of drives. The resulting system uses sys1's drive_bounds.\n\nExample\n\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\nsys_combined = direct_sum(sys1, sys2)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a> \n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/PiccoloQuantumObjects/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/PiccoloQuantumObjects/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/PiccoloQuantumObjects.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/PiccoloQuantumObjects.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/PiccoloQuantumObjects.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/PiccoloQuantumObjects.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n<i> Make simple transformation of complex objects for quantum numerics </i>\n<br>\n\n</div>","category":"section"},{"location":"#PiccoloQuantumObjects","page":"Home","title":"PiccoloQuantumObjects","text":"PiccoloQuantumObjects.jl is a Julia package for working with quantum objects. It provides tools for constructing and manipulating quantum states and operators. It is designed to be used with other packages in the Piccolo.jl ecosystem, such as QuantumCollocation.jl and NamedTrajectories.jl.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is registered! To install, enter the Julia REPL, type ] to enter pkg mode, and then run:\n\npkg> add PiccoloQuantumObjects","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"The following example demonstrates how to create a quantum state, create a quantum operator, and apply the operator to the state:\n\nusing PiccoloQuantumObjects\n\n# Create a quantum state\nstate = ket_from_string(\"g\", [2])\n\n# Create a quantum operator\noperator = PAULIS.X\n\n# Apply the operator to the state\nnew_state = operator * state\n\n# Transform the state to its real representation\nnew_iso_state = ket_to_iso(new_state)\n\n# Transform back\niso_to_ket(new_iso_state)","category":"section"},{"location":"#Building-Documentation","page":"Home","title":"Building Documentation","text":"This package uses a Documenter config that is shared with many of our other repositories. To build the docs, you will need to run the docs setup script to clone and pull down the utility. \n\n# first time only\n./docs/get_docs_utils.sh   # or ./get_docs_utils.sh if cwd is in ./docs/\n\nTo build the docs pages:\n\njulia --project=docs docs/make.jl\n\nor editing the docs live:\n\njulia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"], skip_files=[\"docs/src/index.md\"])\n\nNote: servedocs needs to watch a subset of the files in the docs/ folder. If it watches files that are generated on a docs build/re-build, servedocs will continuously try to re-serve the pages.To prevent this, ensure all generated files are included in the skip dirs or skip files args for servedocs.\n\nFor example, if we forget index.md like so:\n\njulia --project=docs\n> using LiveServer, PiccoloQuantumObjects, Revise\n> servedocs(literate_dir=\"docs/literate\", skip_dirs=[\"docs/src/generated\", \"docs/src/assets/\"])\n\nit will not build and serve.\n\n\n\n\"It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to take away.\" - Antoine de Saint-Exup√©ry","category":"section"},{"location":"generated/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"This quickstart guide will help you get up and running with PiccoloQuantumObjects.jl.","category":"section"},{"location":"generated/quickstart/#Installation","page":"Quickstart","title":"Installation","text":"using Pkg\nPkg.add(\"PiccoloQuantumObjects\")","category":"section"},{"location":"generated/quickstart/#Basic-Usage","page":"Quickstart","title":"Basic Usage","text":"using PiccoloQuantumObjects\nusing LinearAlgebra\nusing SparseArrays\nusing NamedTrajectories","category":"section"},{"location":"generated/quickstart/#Creating-a-Quantum-System","page":"Quickstart","title":"Creating a Quantum System","text":"Define Hamiltonian components\n\nH_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\n\nSpecify control bounds\n\ndrive_bounds = [(-1.0, 1.0), (-1.0, 1.0)]  # Control bounds for each drive\n\nCreate the quantum system\n\nsystem = QuantumSystem(H_drift, H_drives, drive_bounds)","category":"section"},{"location":"generated/quickstart/#Working-with-Quantum-States","page":"Quickstart","title":"Working with Quantum States","text":"Create quantum states\n\nœà_ground = ket_from_string(\"g\", [2])  # Ground state\n\nœà_excited = ket_from_string(\"e\", [2])  # Excited state\n\nCalculate fidelity\n\nfidelity(œà_ground, œà_excited)","category":"section"},{"location":"generated/quickstart/#Simulating-Evolution-(Rollouts)","page":"Quickstart","title":"Simulating Evolution (Rollouts)","text":"Initial state\n\nœà_init = ComplexF64[1.0, 0.0]\n\nDefine control sequence\n\nT = 10  # Number of time steps\ncontrols = rand(2, T)  # Random controls for two drives\nŒît = fill(0.1, T)  # Time step duration\n\nPerform rollout\n\nœàÃÉ_rollout = rollout(œà_init, controls, Œît, system)\n\nCheck final state fidelity\n\nœà_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(œà_init, œà_goal, controls, Œît, system)","category":"section"},{"location":"generated/quickstart/#Open-Quantum-Systems","page":"Quickstart","title":"Open Quantum Systems","text":"Add dissipation operators\n\na = annihilate(2)\ndissipation_operators = [a'a, a]\n\nCreate open quantum system\n\nopen_system = OpenQuantumSystem(\n    H_drives,\n    drive_bounds,\n    dissipation_operators=dissipation_operators\n)","category":"section"},{"location":"generated/quickstart/#Composite-Systems","page":"Quickstart","title":"Composite Systems","text":"Create subsystems\n\nsys1 = QuantumSystem([PAULIS[:X]], [(-1.0, 1.0)])\nsys2 = QuantumSystem([PAULIS[:Y]], [(-1.0, 1.0)])\n\nDefine coupling\n\nH_coupling = 0.1 * kron(PAULIS[:Z], PAULIS[:Z])\n\nCreate composite system\n\ncomposite_sys = CompositeQuantumSystem(\n    H_coupling,\n    Matrix{ComplexF64}[],\n    [sys1, sys2],\n    Float64[]\n)","category":"section"},{"location":"generated/quickstart/#Visualization","page":"Quickstart","title":"Visualization","text":"PiccoloQuantumObjects.jl integrates with NamedTrajectories.jl for plotting trajectories.\n\nusing CairoMakie","category":"section"},{"location":"generated/quickstart/#Plotting-Controls-and-States","page":"Quickstart","title":"Plotting Controls and States","text":"Create a trajectory with controls and states\n\nT_plot = 50\nT_duration = 10.0  # Total evolution time\ncontrols_plot = 0.5 * sin.(2œÄ * (1:T_plot) / T_plot)\nŒît_plot = fill(T_duration / T_plot, T_plot)\n\nPerform a rollout to get the state evolution\n\nœàÃÉ_traj = rollout(œà_init, hcat(controls_plot, -controls_plot)', Œît_plot, system)\n\nCreate a NamedTrajectory for plotting\n\ntraj = NamedTrajectory(\n    (\n        œàÃÉ = œàÃÉ_traj,\n        a = hcat(controls_plot, -controls_plot)',\n        Œît = Œît_plot\n    );\n    timestep=:Œît,\n    controls=:a,\n    initial=(œàÃÉ = ket_to_iso(œà_init),),\n    goal=(œàÃÉ = ket_to_iso(œà_goal),)\n)\n\nPlot the trajectory\n\nplot(traj)","category":"section"},{"location":"generated/quickstart/#Plotting-State-Populations","page":"Quickstart","title":"Plotting State Populations","text":"Use transformations to plot populations directly from isomorphic states\n\nplot(\n    traj,\n    [:a],\n    transformations=[\n        :œàÃÉ => (œàÃÉ -> abs2.(iso_to_ket(œàÃÉ)))\n    ],\n    transformation_labels=[\"Populations\"]\n)","category":"section"},{"location":"generated/quickstart/#Next-Steps","page":"Quickstart","title":"Next Steps","text":"Explore the Quantum Systems manual for detailed system construction\nLearn about Quantum Objects for working with states and operators\nSee Rollouts for simulation and fidelity calculations\nUnderstand Isomorphisms for the underlying mathematical transformations\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/rollouts/#Rollouts-and-fidelity","page":"Rollouts","title":"Rollouts and fidelity","text":"using PiccoloQuantumObjects\nusing NamedTrajectories\nusing SparseArrays # for visualization\nusing LinearAlgebra\n\nRollouts are simulations of a quantum system. In a rollout, controls are integrated forward in time using the dynamics implied by a provided quantum systems. The defualt is to use zero-order hold integration to simulate the evolution‚Äì-that is, the controls are held constant between time steps. For quantum states, the Schr√∂dinger equation is used:\n\npsi(t + Delta t) = expleft(-i H(mathbfa(t)) Delta tright) psi(t)\n\nThe visited states are collected into a matrix of size (2n, T), for the isomorphic Hilbert space dimension 2n and timesteps T.\n\nnote: Note\nAll of the returned rollout are assumed to be real valued. It is helpful to use the appropriate isomorphisms to convert between real and complex quantum objects, and eachcol to iterate over the rollout columns.\n\nThere are rollouts for each kind of quantum object: quantum states, unitary operators, and density operators.\n\nA fidelity function is also provided for each kind of quantum objectand a rollout fidelity function compares the final state of a rollout to a goal state.","category":"section"},{"location":"generated/rollouts/#Fidelity-functions","page":"Rollouts","title":"Fidelity functions","text":"The fidelity functions are used to measure how close two quantum states or operators are to each other.\n\nfidelity calculates the fidelity between two quantum states.\nunitary_fidelity calculates the fidelity between two unitary operators.\n\nState fidelity.\n\nœà = GATES.X * [1.0, 0.0]\nœà_goal = [0.0, 1.0]\nfidelity(œà, œà_goal)\n\nUnitary fidelity of orthogonal operations.\n\nU = GATES.Y\nU_goal = GATES.X\nunitary_fidelity(U, U_goal)","category":"section"},{"location":"generated/rollouts/#Quantum-State-Rollouts","page":"Rollouts","title":"Quantum State Rollouts","text":"The rollout function simulates the evolution of a real valued quantum state under given controls and quantum system.\n\nThe rollout is a matrix of size (2n, T).\n\nT = 10\nœà_init = ComplexF64[1.0, 0.0]\ncontrols = rand(2, T)\nŒît = fill(0.1, T)\nsystem = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]], [(-1.0, 1.0), (-1.0, 1.0)])\nœàÃÉ_rollout = rollout(œà_init, controls, Œît, system)\nœàÃÉ_rollout |> size","category":"section"},{"location":"generated/rollouts/#Quantum-State-Rollout-Fidelity","page":"Rollouts","title":"Quantum State Rollout Fidelity","text":"States must be cast to complex for the rollout to know the difference between real and isomorphic states.\n\nœà_goal = ComplexF64[0.0, 1.0]\nrollout_fidelity(œà_init, œà_goal, controls, Œît, system)\n\nwarning: Warning\nDon't forget to convert the quantum state to the appropriate isomorphism before calculating the fidelity.\n\nfidelity(iso_to_ket(œàÃÉ_rollout[:, end]), œà_goal)\n\nThe initial state and goal are often inferred from the properly configured trajectory of a control problem.\n\ncomponents = (œàÃÉ = zeros(Float64, size(œàÃÉ_rollout)), a = controls, Œît = Œît)\ntraj = NamedTrajectory(\n    components;\n    timestep=:Œît,\n    controls=:a,\n    initial=(œàÃÉ = ket_to_iso(œà_init),),\n    goal=(œàÃÉ = ket_to_iso(œà_goal),),\n)\nrollout_fidelity(traj, system)\n\nnote: Note\nThe rollout fidelity is not the same thing as the fidelity of the final trajectory state.\n\nfidelity(iso_to_ket(traj.œàÃÉ[:, end]), œà_goal)","category":"section"},{"location":"generated/rollouts/#Unitary-Rollouts","page":"Rollouts","title":"Unitary Rollouts","text":"UÃÉ‚Éó_rollout = unitary_rollout(controls, Œît, system)\nUÃÉ‚Éó_rollout |> size\n\nConvert to unitary operators, and have a look at the initial unitary.\n\niso_vec_to_operator.(eachcol(UÃÉ‚Éó_rollout[:, 1])) |> first","category":"section"},{"location":"generated/rollouts/#Open-Quantum-System-Rollouts","page":"Rollouts","title":"Open Quantum System Rollouts","text":"Open rollouts require open quantum systems.\n\nopen_system = OpenQuantumSystem(system)\n\nœÅ_init = œà_init * œà_init'\nœÅÃÉ‚Éó_rollout = open_rollout(œÅ_init, controls, Œît, open_system)\nœÅÃÉ‚Éó_rollout |> size\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/rollouts/#PiccoloQuantumObjects.Rollouts.rollout-generated-rollouts","page":"Rollouts","title":"PiccoloQuantumObjects.Rollouts.rollout","text":"rollout(qtraj, args...; kwargs...)\n\nRoll out a quantum trajectory with new pulse or ODE parameters. Extended in quantum_trajectories module for specific trajectory types.\n\n\n\n\n\n","category":"function"}]
}
