<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Systems · PiccoloQuantumObjects.jl</title><meta name="title" content="Quantum Systems · PiccoloQuantumObjects.jl"/><meta property="og:title" content="Quantum Systems · PiccoloQuantumObjects.jl"/><meta property="twitter:title" content="Quantum Systems · PiccoloQuantumObjects.jl"/><meta name="description" content="Documentation for PiccoloQuantumObjects.jl."/><meta property="og:description" content="Documentation for PiccoloQuantumObjects.jl."/><meta property="twitter:description" content="Documentation for PiccoloQuantumObjects.jl."/><meta property="og:url" content="https://docs.harmoniqs.co/PiccoloQuantumObjects.jl/generated/quantum_systems/"/><meta property="twitter:url" content="https://docs.harmoniqs.co/PiccoloQuantumObjects.jl/generated/quantum_systems/"/><link rel="canonical" href="https://docs.harmoniqs.co/PiccoloQuantumObjects.jl/generated/quantum_systems/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PiccoloQuantumObjects.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PiccoloQuantumObjects.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../isomorphisms/">Isomorphisms</a></li><li><a class="tocitem" href="../quantum_objects/">Quantum Objects</a></li><li class="is-active"><a class="tocitem" href>Quantum Systems</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Systems"><span>Quantum Systems</span></a></li><li><a class="tocitem" href="#Open-quantum-systems"><span>Open quantum systems</span></a></li><li><a class="tocitem" href="#Time-Dependent-Quantum-Systems"><span>Time Dependent Quantum Systems</span></a></li><li><a class="tocitem" href="#Composite-quantum-systems"><span>Composite quantum systems</span></a></li><li class="toplevel"><a class="tocitem" href="#Reachability-tests"><span>Reachability tests</span></a></li><li class="toplevel"><a class="tocitem" href="#Direct-sums"><span>Direct sums</span></a></li></ul></li><li><a class="tocitem" href="../rollouts/">Rollouts</a></li></ul></li><li><a class="tocitem" href="../../lib/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Quantum Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/main/docs/literate/quantum_systems.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Abstract-Quantum-Systems"><a class="docs-heading-anchor" href="#Abstract-Quantum-Systems"><code>Abstract Quantum Systems</code></a><a id="Abstract-Quantum-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Quantum-Systems" title="Permalink"></a></h1><pre><code class="language-julia hljs">using PiccoloQuantumObjects
using SparseArrays # for visualization
⊗ = kron;</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractQuantumSystem</code></pre><p>Abstract type for defining systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_systems/_quantum_systems.jl#L21-L25">source</a></section></article><h2 id="Quantum-Systems"><a class="docs-heading-anchor" href="#Quantum-Systems">Quantum Systems</a><a id="Quantum-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Systems" title="Permalink"></a></h2><p>The <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem"><code>QuantumSystem</code></a> type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians,</p><p class="math-container">\[H = H_{\text{drift}} + \sum_i a_i H_{\text{drives}}^{(i)}\]</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystems.QuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing quantum dynamics.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The Hamiltonian function, excluding dissipation: a -&gt; H(a).</li><li><code>G::Function</code>: The isomorphic generator function, including dissipation, a -&gt; G(a).</li><li><code>levels::Int</code>: The number of levels in the system.</li><li><code>n_drives::Int</code>: The number of drives in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_systems/quantum_systems.jl#L9-L20">source</a></section></article><p><code>QuantumSystem</code>&#39;s are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space.</p><pre><code class="language-julia hljs">H_drift = PAULIS[:Z]
H_drives = [PAULIS[:X], PAULIS[:Y]]
system = QuantumSystem(H_drift, H_drives)

a_drives = [1, 0]
system.H(a_drives)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 1.0+0.0im   1.0+0.0im
 1.0+0.0im  -1.0+0.0im</code></pre><p>To extract the drift and drive Hamiltonians from a <code>QuantumSystem</code>, use the <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}"><code>get_drift</code></a> and <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}"><code>get_drives</code></a> functions.</p><pre><code class="language-julia hljs">get_drift(system) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
 1.0+0.0im       ⋅    
     ⋅      -1.0+0.0im</code></pre><p><em>Get the X drive.</em></p><pre><code class="language-julia hljs">drives = get_drives(system)
drives[1] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      1.0+0.0im
 1.0+0.0im      ⋅    </code></pre><p><em>And the Y drive.</em></p><pre><code class="language-julia hljs">drives[2] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      0.0-1.0im
 0.0+1.0im      ⋅    </code></pre><div class="admonition is-info" id="Note-f013d3c1091dd2d2"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f013d3c1091dd2d2" title="Permalink"></a></header><div class="admonition-body"><p>We can also construct a <code>QuantumSystem</code> directly from a Hamiltonian function. Internally, <code>ForwardDiff.jl</code> is used to compute the drives.</p></div></div><pre><code class="language-julia hljs">H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]
system = QuantumSystem(H, 2)
get_drives(system)[1] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      1.0+0.0im
 1.0+0.0im      ⋅    </code></pre><p><em>Create a noise model with a confusion matrix.</em></p><pre><code class="language-julia hljs">function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])
    b = C * a
    return b[1] * PAULIS.X + b[2] * PAULIS.Y
end

C_matrix = [0.99 0.01; -0.01 1.01]
system = QuantumSystem(a -&gt; H(a, C=C_matrix), 2; params=Dict(:C =&gt; C_matrix))
confused_drives = get_drives(system)
confused_drives[1] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
      ⋅       0.99+0.01im
 0.99-0.01im       ⋅    </code></pre><pre><code class="language-julia hljs">confused_drives[2] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
      ⋅       0.01-1.01im
 0.01+1.01im       ⋅    </code></pre><h2 id="Open-quantum-systems"><a class="docs-heading-anchor" href="#Open-quantum-systems">Open quantum systems</a><a id="Open-quantum-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Open-quantum-systems" title="Permalink"></a></h2><p>We can also construct an <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem"><code>OpenQuantumSystem</code></a> with Lindblad dynamics, enabling a user to pass a list of dissipation operators.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpenQuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing open quantum dynamics.</p><p><strong>Additional fields</strong></p><ul><li><code>dissipation_operators::Vector{AbstractMatrix}</code>: The dissipation operators.</li></ul><p>See also <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem"><code>QuantumSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_systems/quantum_systems.jl#L92-L102">source</a></section></article><p><em>Add a dephasing and annihilation error channel.</em></p><pre><code class="language-julia hljs">H_drives = [PAULIS[:X]]
a = annihilate(2)
dissipation_operators = [a&#39;a, a]
system = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)
system.dissipation_operators[1] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:
     ⋅          ⋅    
     ⋅      1.0+0.0im</code></pre><pre><code class="language-julia hljs">system.dissipation_operators[2] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:
     ⋅      1.0+0.0im
     ⋅          ⋅    </code></pre><div class="admonition is-warning" id="Warning-4557b407df3b8888"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4557b407df3b8888" title="Permalink"></a></header><div class="admonition-body"><p>The Hamiltonian part <code>system.H</code> excludes the Lindblad operators. This is also true for functions that report properties of <code>system.H</code>, such as <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}"><code>get_drift</code></a>, <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}"><code>get_drives</code></a>, and <a href="#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems"><code>is_reachable</code></a>.</p></div></div><pre><code class="language-julia hljs">get_drift(system) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries:
     ⋅          ⋅    
     ⋅          ⋅    </code></pre><h2 id="Time-Dependent-Quantum-Systems"><a class="docs-heading-anchor" href="#Time-Dependent-Quantum-Systems">Time Dependent Quantum Systems</a><a id="Time-Dependent-Quantum-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Dependent-Quantum-Systems" title="Permalink"></a></h2><p>A <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem"><code>TimeDependentQuantumSystem</code></a> is a <code>QuantumSystem</code> with time-dependent Hamiltonians.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystems.TimeDependentQuantumSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeDependentQuantumSystem &lt;: AbstractQuantumSystem</code></pre><p>A struct for storing time-dependent quantum dynamics.</p><p><strong>Fields</strong></p><ul><li><code>H::Function</code>: The Hamiltonian function with time: (a, t) -&gt; H(a, t).</li><li><code>G::Function</code>: The isomorphic generator function with time, (a, t) -&gt; G(a, t).</li><li><code>n_drives::Int</code>: The number of drives in the system.</li><li><code>levels::Int</code>: The number of levels in the system.</li><li><code>params::Dict{Symbol, Any}</code>: A dictionary of parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_systems/time_dependent_quantum_systems.jl#L9-L21">source</a></section></article><p>A function <code>H(a, t)</code> or carrier and phase kwargs are used to specify time-dependent drives,</p><p class="math-container">\[    H(a, t) = H_{\text{drift}} + \sum_i a_i \cos(\omega_i t + \phi_i) H_{\text{drives}}^{(i)}\]</p><p><em>Create a time-dependent Hamiltonian with a time-dependent drive.</em></p><pre><code class="language-julia hljs">H(a, t) = PAULIS.Z + a[1] * cos(t) * PAULIS.X
system = TimeDependentQuantumSystem(H, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TimeDependentQuantumSystem: levels = 2, n_drives = 1</code></pre><p><em>The drift Hamiltonian is the Z operator, but its now a function of time!</em></p><pre><code class="language-julia hljs">get_drift(system)(0.0) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
 1.0+0.0im       ⋅    
     ⋅      -1.0+0.0im</code></pre><p><em>The drive Hamiltonian is the X operator, but its now a function of time!</em></p><pre><code class="language-julia hljs">get_drives(system)[1](0.0) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      1.0+0.0im
 1.0+0.0im      ⋅    </code></pre><p><em>Change the time to π.</em></p><pre><code class="language-julia hljs">get_drives(system)[1](π) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
      ⋅      -1.0+0.0im
 -1.0+0.0im       ⋅    </code></pre><p><em>Similar matrix constructors exist, but with carrier and phase kwargs.</em></p><pre><code class="language-julia hljs">system = TimeDependentQuantumSystem(PAULIS.Z, [PAULIS.X], carriers=[1.0], phases=[0.0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TimeDependentQuantumSystem: levels = 2, n_drives = 1</code></pre><p><em>This is the same as before, t=0.0:</em></p><pre><code class="language-julia hljs">get_drives(system)[1](0.0) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
     ⋅      1.0+0.0im
 1.0+0.0im      ⋅    </code></pre><p><em>and at π:</em></p><pre><code class="language-julia hljs">get_drives(system)[1](π) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:
      ⋅      -1.0+0.0im
 -1.0+0.0im       ⋅    </code></pre><h2 id="Composite-quantum-systems"><a class="docs-heading-anchor" href="#Composite-quantum-systems">Composite quantum systems</a><a id="Composite-quantum-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-quantum-systems" title="Permalink"></a></h2><p>A <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.CompositeQuantumSystem"><code>CompositeQuantumSystem</code></a> is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space.</p><pre><code class="language-julia hljs">system_1 = QuantumSystem([PAULIS[:X]])
system_2 = QuantumSystem([PAULIS[:Y]])
H_drift = PAULIS[:Z] ⊗ PAULIS[:Z]
system = CompositeQuantumSystem(H_drift, [system_1, system_2]);</code></pre><p><em>The drift Hamiltonian is the ZZ coupling.</em></p><pre><code class="language-julia hljs">get_drift(system) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 1.0+0.0im       ⋅           ⋅          ⋅    
     ⋅      -1.0+0.0im       ⋅          ⋅    
     ⋅           ⋅      -1.0+0.0im      ⋅    
     ⋅           ⋅           ⋅      1.0+0.0im</code></pre><p><em>The drives are the X and Y operators on the first and second subsystems.</em></p><pre><code class="language-julia hljs">drives = get_drives(system)
drives[1] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
     ⋅          ⋅      1.0+0.0im      ⋅    
     ⋅          ⋅          ⋅      1.0+0.0im
 1.0+0.0im      ⋅          ⋅          ⋅    
     ⋅      1.0+0.0im      ⋅          ⋅    </code></pre><pre><code class="language-julia hljs">drives[2] |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
     ⋅      0.0-1.0im      ⋅          ⋅    
 0.0+1.0im      ⋅          ⋅          ⋅    
     ⋅          ⋅          ⋅      0.0-1.0im
     ⋅          ⋅      0.0+1.0im      ⋅    </code></pre><h3 id="The-lift_operator-function"><a class="docs-heading-anchor" href="#The-lift_operator-function">The <code>lift_operator</code> function</a><a id="The-lift_operator-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-lift_operator-function" title="Permalink"></a></h3><p>To lift operators acting on a subsystem into the full Hilbert space, use <a href="../../lib/#PiccoloQuantumObjects.QuantumSystems.lift_operator"><code>lift_operator</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystems.lift_operator-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystems.lift_operator-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystems.lift_operator</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lift_operator(operator::AbstractMatrix{&lt;:Number}, i::Int, subsystem_levels::Vector{Int})
lift_operator(operator::AbstractMatrix{&lt;:Number}, i::Int, n_qubits::Int; kwargs...)
lift_operator(operators::AbstractVector{&lt;:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})
lift_operator(operators::AbstractVector{&lt;:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)
lift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})
lift_operator(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)</code></pre><p>Lift an <code>operator</code> acting on the <code>i</code>-th subsystem within <code>subsystem_levels</code> to an operator acting on the entire system spanning <code>subsystem_levels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_systems/composite_quantum_systems.jl#L8-L18">source</a></section></article><p><em>Create an <code>a + a&#39;</code> operator acting on the 1st subsystem of a qutrit and qubit system.</em></p><pre><code class="language-julia hljs">subspace_levels = [3, 2]
lift_operator(create(3) + annihilate(3), 1, subspace_levels) .|&gt; real |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  ⋅    ⋅   1.0       ⋅        ⋅        ⋅ 
  ⋅    ⋅    ⋅       1.0       ⋅        ⋅ 
 1.0   ⋅    ⋅        ⋅       1.41421   ⋅ 
  ⋅   1.0   ⋅        ⋅        ⋅       1.41421
  ⋅    ⋅   1.41421   ⋅        ⋅        ⋅ 
  ⋅    ⋅    ⋅       1.41421   ⋅        ⋅ </code></pre><p><em>Create IXI operator on the 2nd qubit in a 3-qubit system.</em></p><pre><code class="language-julia hljs">lift_operator(PAULIS[:X], 2, 3) .|&gt; real |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ 
 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ </code></pre><p><em>Create an XX operator acting on qubits 3 and 4 in a 4-qubit system.</em></p><pre><code class="language-julia hljs">lift_operator([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|&gt; real |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥
⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦</code></pre><p>We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems.</p><pre><code class="language-julia hljs">#_Here&#39;s another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._
lift_operator(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|&gt; real |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:
⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥
⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦</code></pre><p><em>Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system.</em> <em>The result is independent of the state of the second qubit.</em></p><pre><code class="language-julia hljs">lift_operator(GATES[:CX], [1, 3], 3) .|&gt; real |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:
 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ 
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0
  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ </code></pre><h1 id="Reachability-tests"><a class="docs-heading-anchor" href="#Reachability-tests">Reachability tests</a><a id="Reachability-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Reachability-tests" title="Permalink"></a></h1><p>Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the <a href="#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems"><code>is_reachable</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems" href="#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems"><code>PiccoloQuantumObjects.QuantumSystemUtils.is_reachable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_reachable(gate, hamiltonians; kwargs...)</code></pre><p>Check if the <code>gate</code> is reachable using the given <code>hamiltonians</code>.</p><p><strong>Arguments</strong></p><ul><li><code>gate::AbstractMatrix</code>: target gate</li><li><code>hamiltonians::AbstractVector{&lt;:AbstractMatrix}</code>: generators of the Lie algebra</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>subspace::AbstractVector{&lt;:Int}=1:size(gate, 1)</code>: subspace indices</li><li><code>compute_basis::Bool=true</code>: compute the basis or use the Hamiltonians directly</li><li><code>remove_trace::Bool=true</code>: remove trace from generators</li><li><code>verbose::Bool=true</code>: print information about the operator algebra</li><li><code>atol::Float32=eps(Float32)</code>: absolute tolerance</li></ul><p>See also <a href="../../lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{&lt;:AbstractMatrix{T}}}, Tuple{T}} where T&lt;:Number"><code>QuantumSystemUtils.operator_algebra</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_system_utils.jl#L216-L233">source</a></section><section><div><pre><code class="language-julia hljs">is_reachable(gate::AbstractMatrix{&lt;:Number}, system::AbstractQuantumSystem; kwargs...)</code></pre><p>Check if the <code>gate</code> is reachable using the given <code>system</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>use_drift::Bool=true</code>: include drift Hamiltonian in the generators</li><li><code>kwargs...</code>: keyword arguments for <code>is_reachable</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/quantum_system_utils.jl#L264-L272">source</a></section></article><p><em>Y can be reached by commuting Z and X.</em></p><pre><code class="language-julia hljs">system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])
is_reachable(PAULIS[:Y], system)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p><em>Y cannot be reached by X alone.</em></p><pre><code class="language-julia hljs">system = QuantumSystem([PAULIS[:X]])
is_reachable(PAULIS[:Y], system)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><h1 id="Direct-sums"><a class="docs-heading-anchor" href="#Direct-sums">Direct sums</a><a id="Direct-sums-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-sums" title="Permalink"></a></h1><p>The direct sum of two quantum systems is constructed with the <a href="#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems"><code>direct_sum</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems" href="#PiccoloQuantumObjects.DirectSums.direct_sum-generated-quantum_systems"><code>PiccoloQuantumObjects.DirectSums.direct_sum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Returns the direct sum of two matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/direct_sums.jl#L11-L15">source</a></section><section><div><pre><code class="language-julia hljs">direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Returns the direct sum of two sparse matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/direct_sums.jl#L20-L24">source</a></section><section><div><pre><code class="language-julia hljs">direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)</code></pre><p>Returns the direct sum of two iso_vec operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/direct_sums.jl#L29-L33">source</a></section><section><div><pre><code class="language-julia hljs">direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)</code></pre><p>Returns the direct sum of two <code>QuantumSystem</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/harmoniqs/PiccoloQuantumObjects.jl/blob/b4d8655d514a43b0ada72ed197d42105873431e0/src/direct_sums.jl#L43-L47">source</a></section></article><p><em>Create a pair of non-interacting qubits.</em></p><pre><code class="language-julia hljs">system_1 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])
system_2 = QuantumSystem(PAULIS[:Z], [PAULIS[:X], PAULIS[:Y]])
system = direct_sum(system_1, system_2)
get_drift(system) |&gt; sparse</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:
 1.0+0.0im       ⋅          ⋅           ⋅    
     ⋅      -1.0+0.0im      ⋅           ⋅    
     ⋅           ⋅      1.0+0.0im       ⋅    
     ⋅           ⋅          ⋅      -1.0+0.0im</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantum_objects/">« Quantum Objects</a><a class="docs-footer-nextpage" href="../rollouts/">Rollouts »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 13 August 2025 02:18">Wednesday 13 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
